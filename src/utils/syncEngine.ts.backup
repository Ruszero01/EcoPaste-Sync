import { LISTEN_KEY } from "@/constants";
import { getHistoryData, setImportLogCallback, updateSQL } from "@/database";
import {
	type WebDAVConfig,
	downloadSyncData,
	uploadSyncData,
} from "@/plugins/webdav";
import { globalStore } from "@/stores/global";
import { nanoid } from "nanoid";
import type {
	SyncData,
	SyncItem,
	SyncMetadata,
	SyncResult,
} from "@/types/sync";
import {
	calculateChecksum as calculateStringChecksum,
	generateDeviceId,
} from "@/utils/shared";
import { emit } from "@tauri-apps/api/event";
import { fileContentProcessor } from "./fileContentProcessor";
import { resolveImagePath } from "./path";
import { zipFileManager } from "./zipFileManager";
import { zipImageSyncService } from "@/services/zipImageSyncService";

// å…¨å±€äº‹ä»¶å‘å°„å™¨
let syncEventEmitter: (() => void) | null = null;

/**
 * è®¡ç®—äºŒè¿›åˆ¶æ•°æ®çš„æ ¡éªŒå’Œ
 */
const calculateBinaryChecksum = async (data: Uint8Array): Promise<string> => {
	// ä½¿ç”¨æ›´å¥½çš„å“ˆå¸Œç®—æ³•
	let hash = 5381;
	for (let i = 0; i < data.length; i++) {
		hash = (hash << 5) + hash + data[i]; // hash * 33 + data[i]
	}
	// ç¡®ä¿ä¸ä¸º0ï¼Œå¦‚æœä¸º0åˆ™ä½¿ç”¨é»˜è®¤å€¼
	const result = Math.abs(hash).toString(16);
	return result || "default";
};

// è®¾ç½®é»˜è®¤çš„åŒæ­¥äº‹ä»¶ç›‘å¬å™¨ï¼Œç¡®ä¿ä¸ä¼šå› ä¸ºæ²¡æœ‰ç›‘å¬å™¨è€Œå¤±è´¥
const setDefaultSyncListener = () => {
	// åªæœ‰åœ¨çœŸæ­£æ²¡æœ‰ç›‘å¬å™¨æ—¶æ‰è®¾ç½®é»˜è®¤ç›‘å¬å™¨
	if (!syncEventEmitter) {
		syncEventEmitter = () => {
			// é»˜è®¤ç›‘å¬å™¨ï¼Œä»€ä¹ˆéƒ½ä¸åšï¼Œåªæ˜¯é˜²æ­¢æŠ¥é”™
			addGlobalLog("info", "ğŸ“¡ ä½¿ç”¨é»˜è®¤åŒæ­¥äº‹ä»¶ç›‘å¬å™¨");
		};
		addGlobalLog("info", "ğŸ“¡ å·²è®¾ç½®é»˜è®¤åŒæ­¥äº‹ä»¶ç›‘å¬å™¨");
	}
};

// å…¨å±€æ—¥å¿—å›è°ƒï¼Œç”¨äºå¤–éƒ¨æ—¥å¿—æ˜¾ç¤º
let globalLogCallback:
	| ((
			level: "info" | "success" | "warning" | "error",
			message: string,
			data?: any,
	  ) => void)
	| null = null;

/**
 * è®¾ç½®å…¨å±€æ—¥å¿—å›è°ƒ
 */
export const setGlobalSyncLogCallback = (
	callback: (
		level: "info" | "success" | "warning" | "error",
		message: string,
		data?: any,
	) => void,
) => {
	globalLogCallback = callback;
};

/**
 * æ·»åŠ å…¨å±€æ—¥å¿—
 */
const addGlobalLog = (
	level: "info" | "success" | "warning" | "error",
	message: string,
	data?: any,
) => {
	if (globalLogCallback) {
		globalLogCallback(level, message, data);
	}
};

/**
 * è®¾ç½®åŒæ­¥äº‹ä»¶ç›‘å¬å™¨
 */
export const setSyncEventListener = (listener: () => void) => {
	// æ£€æŸ¥æ˜¯å¦æ˜¯ç›¸åŒçš„ç›‘å¬å™¨ï¼Œé¿å…ä¸å¿…è¦çš„é‡å¤è®¾ç½®
	if (syncEventEmitter === listener) {
		addGlobalLog("info", "ğŸ“¡ åŒæ­¥äº‹ä»¶ç›‘å¬å™¨å·²å­˜åœ¨ï¼Œè·³è¿‡é‡å¤è®¾ç½®");
		return;
	}

	if (syncEventEmitter) {
		addGlobalLog(
			"warning",
			"âš ï¸ æ£€æµ‹åˆ°é‡å¤çš„åŒæ­¥äº‹ä»¶ç›‘å¬å™¨è®¾ç½®ï¼Œå°†è¦†ç›–ä¹‹å‰çš„ç›‘å¬å™¨",
		);
	} else {
		addGlobalLog("info", "ğŸ“¡ è®¾ç½®åŒæ­¥äº‹ä»¶ç›‘å¬å™¨");
	}
	syncEventEmitter = listener;
};

/**
 * è§¦å‘åŒæ­¥äº‹ä»¶
 */
const triggerSyncEvent = () => {
	addGlobalLog("info", "ğŸ”„ å‡†å¤‡è§¦å‘åŒæ­¥äº‹ä»¶", {
		hasListener: !!syncEventEmitter,
	});
	if (syncEventEmitter) {
		addGlobalLog("success", "âœ… æ‰§è¡ŒåŒæ­¥äº‹ä»¶ç›‘å¬å™¨");
		syncEventEmitter();
	} else {
		addGlobalLog("warning", "âš ï¸ æ²¡æœ‰è®¾ç½®åŒæ­¥äº‹ä»¶ç›‘å¬å™¨");
	}
};

export class SyncEngine {
	private config: WebDAVConfig | null = null;
	private deviceId: string = generateDeviceId();
	private isOnline = false;
	private lastSyncTime = 0;
	private lastLocalSnapshot: Map<string, any> = new Map(); // ç”¨äºè·Ÿè¸ªæœ¬åœ°å˜æ›´
	private syncModeConfig: any = null; // æ·»åŠ åŒæ­¥æ¨¡å¼é…ç½®
	private isInitialized = false; // æ·»åŠ åˆå§‹åŒ–çŠ¶æ€æ ‡è®°

	/**
	 * æ£€æŸ¥é¡¹ç›®æ˜¯å¦åº”è¯¥åŒ…å«åœ¨è½»é‡æ¨¡å¼åŒæ­¥ä¸­
	 */
	private shouldIncludeItem(item: any): boolean {
		// å¦‚æœæ²¡æœ‰å¯ç”¨è½»é‡æ¨¡å¼ï¼ŒåŒ…å«æ‰€æœ‰é¡¹ç›®
		if (
			!this.syncModeConfig ||
			!this.syncModeConfig.settings ||
			!this.syncModeConfig.settings.lightweightMode
		) {
			return true;
		}

		const settings = this.syncModeConfig.settings;

		// æ£€æŸ¥æ”¶è—æ¨¡å¼
		if (settings.onlyFavorites) {
			const isFavorite = item.favorite === true || item.favorite === 1;
			if (!isFavorite) {
				this.addLog("info", `ğŸš« è½»é‡æ¨¡å¼-æ”¶è—æ¨¡å¼: è·³è¿‡éæ”¶è—é¡¹ ${item.type}`);
				return false;
			}
			}

		// æ£€æŸ¥å›¾ç‰‡ç±»å‹
		if (item.type === "image" && !settings.includeImages) {
			this.addLog("info", `ğŸš« è½»é‡æ¨¡å¼-å›¾ç‰‡è¿‡æ»¤: è·³è¿‡å›¾ç‰‡é¡¹`);
			return false;
		}

		// æ£€æŸ¥æ–‡ä»¶ç±»å‹
		if (item.type === "files" && !settings.includeFiles) {
			this.addLog("info", `ğŸš« è½»é‡æ¨¡å¼-æ–‡ä»¶è¿‡æ»¤: è·³è¿‡æ–‡ä»¶é¡¹`);
			return false;
		}

		return true;
	}
	private logCallback:
		| ((
				level: "info" | "success" | "warning" | "error",
				message: string,
				data?: any,
		  ) => void)
		| null = null;

	// æ·»åŠ æ–‡ä»¶å¤„ç†å™¨
	private fileProcessor = new FileContentProcessor();

	constructor() {
		this.deviceId = generateDeviceId();
		// è®¾ç½®é»˜è®¤åŒæ­¥äº‹ä»¶ç›‘å¬å™¨ï¼Œé˜²æ­¢å¯åŠ¨æ—¶æŠ¥é”™
		setDefaultSyncListener();
	}

	/**
	 * è®¾ç½®æ—¥å¿—å›è°ƒå‡½æ•°
	 */
	setLogCallback(
		callback: (
			level: "info" | "success" | "warning" | "error",
			message: string,
			data?: any,
		) => void,
	) {
		this.logCallback = callback;
	}

	/**
	 * è®¾ç½®åŒæ­¥æ¨¡å¼é…ç½®
	 */
	setSyncModeConfig(config: any) {
		this.syncModeConfig = config;
		// ç®€åŒ–æ—¥å¿—ï¼Œåªåœ¨é…ç½®çœŸæ­£å˜åŒ–æ—¶è¾“å‡º
	}

	/**
	 * è·å–å®Œæ•´æ–‡ä»¶è·¯å¾„
	 */
	private getFullPath(fileName: string): string {
		if (!this.config) return `/${fileName}`;
		const basePath = this.config.path.startsWith("/")
			? this.config.path
			: `/${this.config.path}`;
		return `${basePath}/${fileName}`;
	}

	/**
	 * è·å–WebDAVæ–‡ä»¶è·¯å¾„ï¼ˆç”¨äºç”¨æˆ·ä¸Šä¼ çš„æ–‡ä»¶ï¼‰
	 */
	private getWebDAVFilePath(subDir: string, fileName: string): string {
		if (!this.config) return `/${subDir}/${fileName}`;
		const basePath = this.config.path.startsWith("/")
			? this.config.path
			: `/${this.config.path}`;
		return `${basePath}/${subDir}/${fileName}`;
	}

	/**
	 * è·å–WebDAVåŸºç¡€è·¯å¾„ï¼ˆç”¨äºç›®å½•åˆ›å»ºï¼‰
	 */
	private getWebDAVBasePath(): string {
		if (!this.config) return "/";
		return this.config.path.startsWith("/")
			? this.config.path
			: `/${this.config.path}`;
	}

	/**
	 * æ·»åŠ æ—¥å¿—
	 */
	private addLog(
		level: "info" | "success" | "warning" | "error",
		message: string,
		data?: any,
	) {
		if (this.logCallback) {
			this.logCallback(level, message, data);
		}
		// åŒæ—¶è¾“å‡ºåˆ°æ§åˆ¶å°ç”¨äºè°ƒè¯•
		const timestamp = new Date().toISOString();
		console.log(
			`[${timestamp}] [${level.toUpperCase()}] ${message}`,
			data || "",
		);
	}

	/**
	 * åˆå§‹åŒ–åŒæ­¥å¼•æ“
	 */
	async initialize(config: WebDAVConfig): Promise<boolean> {
		// å¦‚æœå·²ç»åˆå§‹åŒ–ä¸”é…ç½®æ²¡æœ‰å˜åŒ–ï¼Œè·³è¿‡é‡å¤åˆå§‹åŒ–
		if (this.isInitialized && this.config) {
			const isSameConfig =
				this.config.url === config.url &&
				this.config.username === config.username &&
				this.config.path === config.path;

			if (isSameConfig) {
				this.addLog("info", "ğŸ”„ åŒæ­¥å¼•æ“å·²åˆå§‹åŒ–ï¼Œé…ç½®æœªå˜åŒ–ï¼Œè·³è¿‡é‡å¤åˆå§‹åŒ–");
				return true;
			} else {
				this.addLog("info", "ğŸ”„ æ£€æµ‹åˆ°é…ç½®å˜åŒ–ï¼Œé‡æ–°åˆå§‹åŒ–åŒæ­¥å¼•æ“");
			}
		}

		this.addLog("info", "ğŸš€ å¼€å§‹åˆå§‹åŒ–åŒæ­¥å¼•æ“");

		// è¯¦ç»†è°ƒè¯•é…ç½®ä¼ é€’
		this.addLog("info", `ğŸ” æ¥æ”¶åˆ°çš„é…ç½®å‚æ•°:`, {
			hasConfig: !!config,
			configKeys: config ? Object.keys(config) : 'null',
			url: config?.url,
			username: config?.username,
			hasPassword: !!config?.password,
			path: config?.path
		});

		this.addLog("info", `âš™ï¸ WebDAVé…ç½®: ${config?.url || 'undefined'}`);

		this.config = config;
		this.isOnline = true;

		// è°ƒè¯•ï¼šç«‹å³éªŒè¯é…ç½®æ˜¯å¦è®¾ç½®æˆåŠŸ
		this.addLog("info", `ğŸ” é…ç½®è®¾ç½®éªŒè¯: ${this.config ? 'æˆåŠŸ' : 'å¤±è´¥'} - ${this.config?.url || 'undefined'}`);

		// è®¾ç½®ZIPæ–‡ä»¶ç®¡ç†å™¨çš„WebDAVé…ç½®
		zipFileManager.setWebDAVConfig(config);
		this.addLog("info", "âœ… ZIPæ–‡ä»¶ç®¡ç†å™¨é…ç½®å·²è®¾ç½®");

		// åˆå§‹åŒ–æœ¬åœ°æ•°æ®å¿«ç…§
		await this.initializeLocalSnapshot();
		this.addLog("info", "âœ… æœ¬åœ°æ•°æ®å¿«ç…§åˆå§‹åŒ–å®Œæˆ");

		// è°ƒè¯•ï¼šå†æ¬¡éªŒè¯é…ç½®æ˜¯å¦ä»ç„¶å­˜åœ¨
		this.addLog("info", `ğŸ” åˆå§‹åŒ–åé…ç½®éªŒè¯: ${this.config ? 'å­˜åœ¨' : 'ä¸¢å¤±'} - ${this.config?.url}`);

		// æ ‡è®°ä¸ºå·²åˆå§‹åŒ–
		this.isInitialized = true;
		this.addLog("info", "âœ… åŒæ­¥å¼•æ“åˆå§‹åŒ–å®Œæˆ");

		return true;
	}

	/**
	 * åˆå§‹åŒ–æœ¬åœ°æ•°æ®å¿«ç…§
	 */
	private async initializeLocalSnapshot(): Promise<void> {
		try {
			const localData = await getHistoryData();
			this.lastLocalSnapshot = new Map(
				(localData as any[]).map((item: any) => [item.id, item]),
			);
			this.addLog("info", "ğŸ“¸ æœ¬åœ°æ•°æ®å¿«ç…§å·²åˆå§‹åŒ–", {
				count: (localData as any[]).length,
			});
		} catch (error) {
			this.addLog("error", "âŒ åˆå§‹åŒ–æœ¬åœ°å¿«ç…§å¤±è´¥", { error });
		}
	}

	/**
	 * è·å–è®¾å¤‡ID
	 */
	getDeviceId(): string {
		return this.deviceId;
	}

	/**
	 * ç”ŸæˆåŒæ­¥æ–‡ä»¶è·¯å¾„
	 */
	// private getSyncFileName(): string {
	// 	const timestamp = new Date().toISOString().split("T")[0]; // YYYY-MM-DD
	// 	return `sync-${timestamp}.json`;
	// }

	/**
	 * è·å–å…¨é‡åŒæ­¥æ–‡ä»¶è·¯å¾„
	 */
	private getFullSyncFilePath(): string {
		return this.getFullPath("sync-data.json");
	}

	/**
	 * è·å–å…ƒæ•°æ®æ–‡ä»¶è·¯å¾„
	 */
	private getMetadataFilePath(): string {
		return this.getFullPath("metadata.json");
	}

	/**
	 * åˆ†ææœ¬åœ°æ•°æ®å˜æ›´ï¼ˆæ–°å¢ã€ä¿®æ”¹ã€åˆ é™¤ï¼‰
	 */
	private async analyzeLocalChanges(): Promise<{
		added: any[];
		modified: any[];
		deleted: string[];
	}> {
		try {
			const currentData = await getHistoryData();
			const currentMap = new Map(
				(currentData as any[]).map((item: any) => [item.id, item]),
			);

			const added: any[] = [];
			const modified: any[] = [];
			const deleted: string[] = [];

			// æ£€æŸ¥æ–°å¢å’Œä¿®æ”¹
			for (const [id, item] of currentMap) {
				const lastItem = this.lastLocalSnapshot.get(id as string);
				if (!lastItem) {
					// æ–°å¢çš„
					added.push(item);
				} else if (JSON.stringify(item) !== JSON.stringify(lastItem)) {
					// ä¿®æ”¹çš„
					modified.push(item);
				}
			}

			// æ£€æŸ¥åˆ é™¤
			for (const [id] of this.lastLocalSnapshot) {
				if (!currentMap.has(id)) {
					deleted.push(id);
				}
			}

			// æ›´æ–°å¿«ç…§
			this.lastLocalSnapshot = currentMap as Map<string, any>;

			return { added, modified, deleted };
		} catch (error) {
			this.addLog("error", "âŒ åˆ†ææœ¬åœ°å˜æ›´å¤±è´¥", { error });
			throw error;
		}
	}

	/**
	 * åŒå‘æ™ºèƒ½åŒæ­¥
	 */
	/**
	 * ç®€åŒ–çš„ç»Ÿä¸€åŒæ­¥æ–¹æ³• - ç›´æ¥æ‰§è¡ŒåŒæ­¥é€»è¾‘
	 */
	async performBidirectionalSync(): Promise<SyncResult> {
		if (!this.config) {
			throw new Error("WebDAVé…ç½®æœªåˆå§‹åŒ–");
		}

		const startTime = Date.now();
		const result: SyncResult = {
			success: false,
			uploaded: 0,
			downloaded: 0,
			conflicts: [],
			errors: [],
			duration: 0,
			timestamp: startTime,
		};

		try {
			this.addLog("info", "ğŸš€ å¼€å§‹ç®€åŒ–åŒæ­¥æµç¨‹");

			// 1. æ ¹æ®åŒæ­¥æ¨¡å¼é…ç½®è·å–å¹¶è¿‡æ»¤æœ¬åœ°æ•°æ®
			this.addLog("info", "ğŸ“Š å‡†å¤‡æœ¬åœ°åŒæ­¥æ•°æ®...");
			const syncData = await this.convertLocalToSyncDataWithDeleted();

			this.addLog("info", "ğŸ“‹ æœ¬åœ°æ•°æ®å‡†å¤‡å®Œæˆ", {
				åŸå§‹æ•°æ®é‡: syncData.items.length,
				åˆ é™¤è®°å½•: syncData.deleted.length,
				åŒæ­¥æ¨¡å¼: this.syncModeConfig?.mode || "unknown",
				è®¾å¤‡ID: this.deviceId,
			});

			// 2. ä¸‹è½½è¿œç¨‹æ•°æ®å¹¶å¤„ç†å›¾ç‰‡æ–‡ä»¶åŒæ­¥
			this.addLog("info", "ğŸ”„ å¼€å§‹ä¸‹è½½è¿œç¨‹æ•°æ®å¹¶å¤„ç†å›¾ç‰‡åŒæ­¥");
			await this.downloadRemoteDataAndProcessImages();
			this.addLog("info", "âœ… å›¾ç‰‡åŒæ­¥å¤„ç†å®Œæˆ");

			// 3. ä¸Šä¼ æœ¬åœ°æ•°æ®ï¼ˆç»Ÿä¸€åŒæ­¥æ–¹æ³•ï¼‰
			this.addLog("info", "â˜ï¸ å¼€å§‹ä¸Šä¼ åŒæ­¥æ•°æ®...");
			const filePath = this.getFullSyncFilePath();

			const uploadResult = await uploadSyncData(
				this.config,
				filePath,
				JSON.stringify(syncData, null, 2),
			);

			if (uploadResult.success) {
				result.uploaded = syncData.items.length;
				result.success = true;
				this.lastSyncTime = Date.now();

				// æ˜ç¡®è®°å½•å®é™…åŒæ­¥çš„é¡¹ç›®æ•°é‡
				this.addLog("success", "âœ… åŒæ­¥å®Œæˆ", {
					åŒæ­¥é¡¹ç›®æ•°é‡: syncData.items.length,
					åˆ é™¤è®°å½•æ•°é‡: syncData.deleted.length,
					æ–‡ä»¶è·¯å¾„: filePath,
					åŒæ­¥è€—æ—¶: `${Date.now() - startTime}ms`,
				});

				// 3. æ›´æ–°å…ƒæ•°æ®
				await this.updateMetadata();

				// 4. ç›´æ¥è§¦å‘ç•Œé¢åˆ·æ–°
				this.addLog("info", "ğŸ”„ è§¦å‘ç•Œé¢åˆ·æ–°");
				try {
					emit(LISTEN_KEY.REFRESH_CLIPBOARD_LIST);
					this.addLog("success", "âœ… ç•Œé¢åˆ·æ–°æˆåŠŸ");
				} catch (error) {
					this.addLog("error", "âŒ ç•Œé¢åˆ·æ–°å¤±è´¥", {
						error: error instanceof Error ? error.message : String(error),
					});
					result.errors.push("ç•Œé¢åˆ·æ–°å¤±è´¥");
				}
			} else {
				const errorMsg = uploadResult.error_message || "ä¸Šä¼ å¤±è´¥";
				result.errors.push(errorMsg);
				this.addLog("error", "âŒ åŒæ­¥ä¸Šä¼ å¤±è´¥", {
					error: errorMsg,
					æ–‡ä»¶è·¯å¾„: filePath,
				});

				// å³ä½¿ä¸Šä¼ å¤±è´¥ä¹Ÿå°è¯•åˆ·æ–°ç•Œé¢
				try {
					emit(LISTEN_KEY.REFRESH_CLIPBOARD_LIST);
				} catch (refreshError) {
					this.addLog("error", "âŒ å¤±è´¥åç•Œé¢åˆ·æ–°ä¹Ÿå¤±è´¥");
				}
			}
		} catch (error) {
			const errorMessage =
				error instanceof Error ? error.message : String(error);
			result.errors.push(errorMessage);

			this.addLog("error", "âŒ åŒæ­¥è¿‡ç¨‹å¼‚å¸¸", {
				error: errorMessage,
				stack: error instanceof Error ? error.stack : undefined,
			});

			// å¼‚å¸¸æ—¶ä¹Ÿå°è¯•åˆ·æ–°ç•Œé¢
			try {
				emit(LISTEN_KEY.REFRESH_CLIPBOARD_LIST);
			} catch (refreshError) {
				this.addLog("error", "âŒ å¼‚å¸¸åç•Œé¢åˆ·æ–°ä¹Ÿå¤±è´¥");
			}
		}

		result.duration = Date.now() - startTime;

		this.addLog("info", "ğŸ åŒæ­¥æµç¨‹ç»“æŸ", {
			æˆåŠŸçŠ¶æ€: result.success,
			ä¸Šä¼ æ•°é‡: result.uploaded,
			ä¸‹è½½æ•°é‡: result.downloaded,
			é”™è¯¯æ•°é‡: result.errors.length,
			æ€»è€—æ—¶: `${result.duration}ms`,
		});

		return result;
	}

	/**
	 * æ‰§è¡ŒçœŸæ­£çš„åŒå‘æ•°æ®åˆå¹¶
	 */
	private async performTrueBidirectionalMerge(
		cloudData: SyncItem[],
		localChanges: { added: any[]; modified: any[]; deleted: string[] },
		cloudDeletedItems: string[] = [],
	): Promise<{
		needsUpload: boolean;
		uploaded: number;
		downloaded: number;
		conflicts: string[];
		deletedItems: string[];
	}> {
		const cloudMap = new Map(cloudData.map((item: any) => [item.id, item]));
		const localData = await getHistoryData();
		const localMap = new Map(
			(localData as any[]).map((item: any) => [item.id, item]),
		);

		// è®°å½•å½“å‰åŒæ­¥æ¨¡å¼é…ç½®
		this.addLog("info", "ğŸ”§ åŒå‘åŒæ­¥ - å½“å‰åŒæ­¥æ¨¡å¼é…ç½®", {
			æ¨¡å¼: this.syncModeConfig?.mode,
			åŒ…å«å›¾ç‰‡: this.syncModeConfig?.settings?.includeImages,
			åŒ…å«æ–‡ä»¶: this.syncModeConfig?.settings?.includeFiles,
			æ”¶è—æ¨¡å¼: this.syncModeConfig?.settings?.onlyFavorites,
			è½»é‡æ¨¡å¼:
				!this.syncModeConfig?.settings?.includeImages &&
				!this.syncModeConfig?.settings?.includeFiles,
		});

		// ç»Ÿè®¡æœ¬åœ°æ•°æ®ç±»å‹
		const localTypeStats = {
			text: 0,
			html: 0,
			rtf: 0,
			image: 0,
			files: 0,
		};
		localData.forEach((item: any) => {
			if (localTypeStats.hasOwnProperty(item.type)) {
				localTypeStats[item.type as keyof typeof localTypeStats]++;
			}
		});

		this.addLog("info", "ğŸ“Š æœ¬åœ°æ•°æ®ç»Ÿè®¡", {
			æœ¬åœ°æ•°æ®æ€»æ•°: localData.length,
			æœ¬åœ°ç±»å‹ç»Ÿè®¡: localTypeStats,
			æœ¬åœ°å˜æ›´: {
				added: localChanges.added.length,
				modified: localChanges.modified.length,
				deleted: localChanges.deleted.length,
			},
		});

		// let _needsUpload = false; // æœªä½¿ç”¨çš„å˜é‡ï¼Œæ³¨é‡Šæ‰
		let downloaded = 0;
		const conflicts: string[] = [];

		// åˆå¹¶æ‰€æœ‰åˆ é™¤è®°å½•
		const allDeletedItems = [
			...new Set([...cloudDeletedItems, ...localChanges.deleted]),
		];

		// 1. å¤„ç†äº‘ç«¯æ–°å¢çš„æ•°æ®ï¼ˆæœ¬åœ°æ²¡æœ‰çš„ï¼Œä¸”ä¸åœ¨åˆ é™¤åˆ—è¡¨ä¸­ï¼‰
		for (const [id, cloudItem] of cloudMap) {
			if (!localMap.has(id) && !allDeletedItems.includes(id)) {
				// æ ¹æ®åŒæ­¥æ¨¡å¼é…ç½®è¿‡æ»¤äº‘ç«¯æ•°æ®
				if (this.syncModeConfig && this.syncModeConfig.settings) {
					const settings = this.syncModeConfig.settings;

					// æ”¶è—æ¨¡å¼ï¼šåªå¤„ç†æ”¶è—çš„äº‘ç«¯æ•°æ®
					if (settings.onlyFavorites) {
						const isFavorite =
							cloudItem.favorite === true || cloudItem.favorite === 1;
						if (!isFavorite) {
							this.addLog(
								"info",
								`ğŸ”– æ”¶è—æ¨¡å¼è·³è¿‡éæ”¶è—äº‘ç«¯æ•°æ®: ${cloudItem.type} - ${cloudItem.search?.substring(0, 20)}...`,
							);
							continue;
						}
					}

					// æ ¹æ®å†…å®¹ç±»å‹è¿‡æ»¤
					if (cloudItem.type === "text" && !settings.includeText) {
						this.addLog(
							"info",
							`ğŸ“ è·³è¿‡æ–‡æœ¬ç±»å‹äº‘ç«¯æ•°æ®: ${cloudItem.search?.substring(0, 20)}...`,
						);
						continue;
					}
					if (cloudItem.type === "html" && !settings.includeHtml) {
						this.addLog(
							"info",
							`ğŸŒ è·³è¿‡HTMLç±»å‹äº‘ç«¯æ•°æ®: ${cloudItem.search?.substring(0, 20)}...`,
						);
						continue;
					}
					if (cloudItem.type === "rtf" && !settings.includeRtf) {
						this.addLog(
							"info",
							`ğŸ“„ è·³è¿‡å¯Œæ–‡æœ¬ç±»å‹äº‘ç«¯æ•°æ®: ${cloudItem.search?.substring(0, 20)}...`,
						);
						continue;
					}
					if (cloudItem.type === "image" && !settings.includeImages) {
						this.addLog(
							"info",
							`ğŸ–¼ï¸ è·³è¿‡å›¾ç‰‡ç±»å‹äº‘ç«¯æ•°æ®: ${cloudItem.search?.substring(0, 20)}...`,
						);
						continue;
					}
					if (cloudItem.type === "files" && !settings.includeFiles) {
						this.addLog(
							"info",
							`ğŸ“ è·³è¿‡æ–‡ä»¶ç±»å‹äº‘ç«¯æ•°æ®: ${cloudItem.search?.substring(0, 20)}...`,
						);
						continue;
					}
				}
				// æ£€æŸ¥æœ¬åœ°æ˜¯å¦å·²æœ‰ç›¸åŒå†…å®¹çš„æ¡ç›®ï¼ˆä¸åŒIDï¼‰
				let existingDuplicate = false;
				for (const [localId, localItem] of localMap) {
					if (
						(localItem as any).type === cloudItem.type &&
						(localItem as any).value === cloudItem.value
					) {
						// å‘ç°é‡å¤å†…å®¹ï¼Œåˆå¹¶ä¿¡æ¯
						existingDuplicate = true;

						// æ™ºèƒ½åˆå¹¶æ”¶è—çŠ¶æ€
						const resolvedFavorite = this.resolveFavoriteStatus(
							localItem,
							cloudItem,
						);

						// ä¿ç•™æœ¬åœ°é¡¹ï¼Œä½†æ›´æ–°ä¸€äº›äº‘ç«¯çš„ä¿¡æ¯
						const mergedItem = {
							...localItem,
							count: Math.max((localItem as any).count, cloudItem.count),
							note: (localItem as any).note || cloudItem.note,
							favorite: resolvedFavorite,
						};
						localMap.set(localId, mergedItem);

						// è®°å½•åˆå¹¶æ—¥å¿—ï¼Œç‰¹åˆ«å…³æ³¨æ”¶è—çŠ¶æ€
						const favoriteChanged =
							(localItem as any).favorite !== resolvedFavorite;
						this.addLog(
							"info",
							`ğŸ”— åˆå¹¶é‡å¤å†…å®¹: ${cloudItem.type} - ${cloudItem.search?.substring(0, 20)}...${favoriteChanged ? " (æ”¶è—çŠ¶æ€å·²æ›´æ–°)" : ""}`,
							{
								localFavorite: (localItem as any).favorite,
								cloudFavorite: cloudItem.favorite,
								resolvedFavorite,
							},
						);
						break;
					}
				}

				if (!existingDuplicate) {
					// äº‘ç«¯æœ‰ï¼Œæœ¬åœ°æ²¡æœ‰ï¼Œä¸”ä¸åœ¨ä»»ä½•åˆ é™¤åˆ—è¡¨ä¸­ â†’ ä¸‹è½½åˆ°æœ¬åœ°
					localMap.set(id, {
						id: cloudItem.id,
						type: cloudItem.type,
						group: cloudItem.group,
						value: cloudItem.value,
						search: cloudItem.search,
						count: cloudItem.count,
						width: cloudItem.width,
						height: cloudItem.height,
						favorite: cloudItem.favorite,
						createTime: cloudItem.createTime,
						note: cloudItem.note,
						subtype: cloudItem.subtype,
					});
					downloaded++;
					this.addLog(
						"info",
						`â¬‡ï¸ ä¸‹è½½äº‘ç«¯æ–°æ•°æ®: ${cloudItem.type} - ${cloudItem.search?.substring(0, 20)}...`,
					);
				}
			} else if (localMap.has(id) && allDeletedItems.includes(id)) {
				// æœ¬åœ°æœ‰ï¼Œä½†åœ¨åˆ é™¤åˆ—è¡¨ä¸­ â†’ ä»æœ¬åœ°åˆ é™¤
				localMap.delete(id);
				this.addLog(
					"info",
					`ğŸ—‘ï¸ åŒæ­¥åˆ é™¤æœ¬åœ°æ•°æ®: ${cloudItem.type} - ${cloudItem.search?.substring(0, 20)}...`,
				);
			} else if (!localMap.has(id) && allDeletedItems.includes(id)) {
				// äº‘ç«¯æœ‰ï¼Œæœ¬åœ°æ²¡æœ‰ï¼Œä¸”åœ¨åˆ é™¤åˆ—è¡¨ä¸­ â†’ è·³è¿‡ï¼ˆå·²åˆ é™¤ï¼‰
				this.addLog(
					"info",
					`â­ï¸ è·³è¿‡å·²åˆ é™¤çš„æ•°æ®: ${cloudItem.type} - ${cloudItem.search?.substring(0, 20)}...`,
				);
			}
		}

		// 2. å¤„ç†å†²çªï¼ˆä¸¤è¾¹éƒ½æœ‰ä½†å†…å®¹ä¸åŒï¼Œä¸”ä¸åœ¨åˆ é™¤åˆ—è¡¨ä¸­ï¼‰
		for (const [id, cloudItem] of cloudMap) {
			if (!allDeletedItems.includes(id)) {
				const localItem = localMap.get(id);
				if (localItem) {
					const cloudTime = new Date(cloudItem.createTime).getTime();
					const localTime = new Date((localItem as any).createTime).getTime();

					if (cloudTime !== localTime) {
						// æ—¶é—´ä¸åŒï¼Œéœ€è¦è§£å†³å†²çª
						if (cloudTime > localTime) {
							// äº‘ç«¯æ›´æ–°ï¼Œä½¿ç”¨äº‘ç«¯æ•°æ®
							localMap.set(id, {
								id: cloudItem.id,
								type: cloudItem.type,
								group: cloudItem.group,
								value: cloudItem.value,
								search: cloudItem.search,
								count: cloudItem.count,
								width: cloudItem.width,
								height: cloudItem.height,
								favorite: cloudItem.favorite,
								createTime: cloudItem.createTime,
								note: cloudItem.note,
								subtype: cloudItem.subtype,
							});
							this.addLog(
								"info",
								`ğŸ”„ ä½¿ç”¨æ›´æ–°çš„äº‘ç«¯æ•°æ®: ${cloudItem.type} - ${cloudItem.search?.substring(0, 20)}...`,
							);
						} else {
							// æœ¬åœ°æ›´æ–°ï¼Œæ ‡è®°éœ€è¦ä¸Šä¼ 
							// _needsUpload = true; // æœªä½¿ç”¨çš„å˜é‡ï¼Œæ³¨é‡Šæ‰
							this.addLog(
								"info",
								`âœ… æœ¬åœ°æ•°æ®æ›´æ–°ï¼Œå°†åŒæ­¥åˆ°äº‘ç«¯: ${(localItem as any).type} - ${(localItem as any).search?.substring(0, 20)}...`,
							);
						}
					}
				}
			}
		}

		// 3. æ„å»ºæœ€ç»ˆçš„æ•°æ®é›†ï¼ˆæ’é™¤æ‰€æœ‰åˆ é™¤é¡¹ï¼‰
		const finalData = Array.from(localMap.values()).filter(
			(item: any) => !allDeletedItems.includes(item.id),
		);

		// 4. ä¿å­˜åˆå¹¶åçš„æœ¬åœ°æ•°æ® - æ€»æ˜¯ä¿å­˜ä»¥ç¡®ä¿æ•°æ®ä¸€è‡´æ€§
		this.addLog(
			"info",
			`ğŸ’¾ ä¿å­˜åˆå¹¶åçš„æœ¬åœ°æ•°æ® ${finalData.length} æ¡ï¼Œæ’é™¤äº† ${allDeletedItems.length} ä¸ªåˆ é™¤é¡¹`,
		);

		// è®°å½•ä¿å­˜å‰çš„æ•°æ®çŠ¶æ€ç”¨äºè°ƒè¯•
		this.addLog("info", "ğŸ” æ•°æ®ä¿å­˜å‰çŠ¶æ€æ£€æŸ¥", {
			localMapSize: localMap.size,
			finalDataLength: finalData.length,
			deletedItemsCount: allDeletedItems.length,
			downloadedCount: downloaded,
			sampleLocalData:
				localMap.size > 0
					? {
							firstId: Array.from(localMap.keys())[0],
							firstType: (Array.from(localMap.values())[0] as any)?.type,
							firstSearch: (
								Array.from(localMap.values())[0] as any
							)?.search?.substring(0, 20),
						}
					: null,
		});

		if (this.logCallback) {
			setImportLogCallback((message, data) => {
				this.logCallback!("info", `ğŸ’¾ ${message}`, data);
			});
		}

		// ä½¿ç”¨æ™ºèƒ½åˆå¹¶è€Œä¸æ˜¯æ¸…ç©ºé‡å»º
		await this.mergeHistoryData(finalData);
		this.addLog("success", "âœ… æœ¬åœ°æ•°æ®åˆå¹¶å®Œæˆ");

		// 5. è§¦å‘ç•Œé¢åˆ·æ–°äº‹ä»¶
		this.addLog("info", "ğŸ”„ è§¦å‘ç•Œé¢åˆ·æ–°äº‹ä»¶");
		triggerSyncEvent();

		// 6. ä½¿ç”¨é¡¹ç›®åŸæœ‰çš„åˆ·æ–°äº‹ä»¶
		this.addLog("info", "ğŸ“¢ å‘é€é¡¹ç›®æ ‡å‡†åˆ·æ–°äº‹ä»¶");
		try {
			emit(LISTEN_KEY.REFRESH_CLIPBOARD_LIST);
			this.addLog("success", "âœ… é¡¹ç›®æ ‡å‡†åˆ·æ–°äº‹ä»¶å‘é€æˆåŠŸ");
		} catch (error) {
			this.addLog("error", "âŒ é¡¹ç›®æ ‡å‡†åˆ·æ–°äº‹ä»¶å‘é€å¤±è´¥", {
				error: error instanceof Error ? error.message : String(error),
			});
		}

		return {
			needsUpload:
				localChanges.added.length > 0 ||
				localChanges.modified.length > 0 ||
				localChanges.deleted.length > 0 ||
				cloudDeletedItems.length > 0,
			uploaded: 0, // å®é™…ä¸Šä¼ æ•°é‡åœ¨ä¸Šä¼ æ—¶ç»Ÿè®¡
			downloaded,
			conflicts,
			deletedItems: allDeletedItems,
		};
	}

	/**
	 * å…¨é‡åŒæ­¥ä¸Šä¼ ï¼ˆåŒ…å«åˆ é™¤è®°å½•ï¼‰
	 */
	async fullSyncUploadWithDeleted(
		deletedItems: string[] = [],
	): Promise<SyncResult> {
		if (!this.config) {
			throw new Error("WebDAVé…ç½®æœªåˆå§‹åŒ–");
		}

		const startTime = Date.now();
		const result: SyncResult = {
			success: false,
			uploaded: 0,
			downloaded: 0,
			conflicts: [],
			errors: [],
			duration: 0,
			timestamp: startTime,
		};

		try {
			// 1. è·å–æœ¬åœ°æ•°æ®
			const syncData =
				await this.convertLocalToSyncDataWithDeleted(deletedItems);

			// 2. ç›´æ¥ä¸Šä¼ æ–‡ä»¶ï¼ˆä½¿ç”¨ç”¨æˆ·é…ç½®çš„ç›®å½•ï¼‰
			const filePath = this.getFullSyncFilePath();
			this.addLog("info", "â˜ï¸ å¼€å§‹ä¸Šä¼ å…¨é‡åŒæ­¥æ–‡ä»¶ï¼ˆåŒ…å«åˆ é™¤è®°å½•ï¼‰", {
				filePath,
				itemCount: syncData.items.length,
				deletedCount: syncData.deleted.length,
			});

			const uploadResult = await uploadSyncData(
				this.config,
				filePath,
				JSON.stringify(syncData, null, 2),
			);

			if (uploadResult.success) {
				result.uploaded = syncData.items.length;
				result.success = true;

				// 3. æ›´æ–°å…ƒæ•°æ®
				await this.updateMetadata();
				this.lastSyncTime = Date.now();
				this.addLog(
					"success",
					`âœ… ä¸Šä¼ å®Œæˆï¼ŒåŒæ­¥äº† ${syncData.items.length} ä¸ªé¡¹ç›®ï¼ŒåŒ…å« ${syncData.deleted.length} ä¸ªåˆ é™¤è®°å½•`,
				);
			} else {
				result.errors.push(uploadResult.error_message || "ä¸Šä¼ å¤±è´¥");
			}
		} catch (error) {
			result.errors.push(
				error instanceof Error ? error.message : String(error),
			);
		}

		result.duration = Date.now() - startTime;
		return result;
	}

	/**
	 * å°†æœ¬åœ°å†å²æ•°æ®è½¬æ¢ä¸ºåŒæ­¥æ•°æ®æ ¼å¼ï¼ˆåŒ…å«åˆ é™¤è®°å½•ï¼‰
	 */
	private async convertLocalToSyncDataWithDeleted(
		deletedItems: string[] = [],
	): Promise<SyncData> {
		try {
			const localData = await getHistoryData();
			const syncItems: SyncItem[] = [];

			console.log("=== æ•°æ®è½¬æ¢å¼€å§‹ ===", { æœ¬åœ°æ•°æ®é‡: localData.length, åŒæ­¥æ¨¡å¼: this.syncModeConfig?.mode });

			this.addLog("info", "ğŸš€ å¼€å§‹è½¬æ¢æœ¬åœ°æ•°æ®ä¸ºåŒæ­¥æ ¼å¼", {
				æœ¬åœ°æ•°æ®æ•°é‡: localData.length,
				WebDAVé…ç½®çŠ¶æ€: !!this.config,
				syncModeConfigçŠ¶æ€: !!this.syncModeConfig,
			});

			// è®°å½•å½“å‰åŒæ­¥æ¨¡å¼é…ç½®
			this.addLog("info", "ğŸ”§ å½“å‰åŒæ­¥æ¨¡å¼é…ç½®", {
				æ¨¡å¼: this.syncModeConfig?.mode,
				åŒ…å«å›¾ç‰‡: this.syncModeConfig?.settings?.includeImages,
				åŒ…å«æ–‡ä»¶: this.syncModeConfig?.settings?.includeFiles,
				æ”¶è—æ¨¡å¼: this.syncModeConfig?.settings?.onlyFavorites,
				è½»é‡æ¨¡å¼:
					!this.syncModeConfig?.settings?.includeImages &&
					!this.syncModeConfig?.settings?.includeFiles,
			});

			// ä½¿ç”¨ä¸ç•Œé¢ç›¸åŒçš„å»é‡é€»è¾‘ï¼šå¯¹äºç›¸åŒ type å’Œ value çš„å†…å®¹ï¼Œåªä¿ç•™æœ€æ–°çš„ä¸€ä¸ª
			const uniqueItems: any[] = [];
			const seenKeys = new Set<string>();

			// æ•°æ®åº“å·²ç»æŒ‰æ—¶é—´é™åºæ’åˆ—ï¼Œæ‰€ä»¥ç¬¬ä¸€ä¸ªé‡åˆ°çš„å°±æ˜¯æœ€æ–°çš„
			for (const item of localData as any[]) {
				const key = `${item.type}:${item.value}`;

				if (!seenKeys.has(key)) {
					seenKeys.add(key);
					uniqueItems.push(item);
				}
			}

			// æ ¹æ®åŒæ­¥æ¨¡å¼é…ç½®è¿‡æ»¤æ•°æ®
			let filteredItems = uniqueItems;
			if (this.syncModeConfig && this.syncModeConfig.settings) {
				const settings = this.syncModeConfig.settings;
				const originalCount = filteredItems.length;

				// æ”¶è—æ¨¡å¼ï¼šåªåŒæ­¥æ”¶è—çš„å†…å®¹
				if (settings.onlyFavorites) {
					filteredItems = filteredItems.filter((item) => {
						// å¤„ç†æ•°æ®åº“ä¸­çš„favoriteå­—æ®µï¼Œå¯èƒ½æ˜¯æ•°å­—(0/1)æˆ–å¸ƒå°”å€¼
						const isFavorite = item.favorite === true || item.favorite === 1;
						return isFavorite;
					});
					this.addLog("info", "ğŸ”– æ”¶è—æ¨¡å¼è¿‡æ»¤å®Œæˆ", {
						è¿‡æ»¤å‰: originalCount,
						è¿‡æ»¤å: filteredItems.length,
					});
				}

				// æ ¹æ®å†…å®¹ç±»å‹è¿‡æ»¤
				filteredItems = filteredItems.filter((item) => {
					// æ–‡æœ¬ç±»å‹
					if (item.type === "text" && !settings.includeText) {
						return false;
					}
					// HTMLç±»å‹
					if (item.type === "html" && !settings.includeHtml) {
						return false;
					}
					// å¯Œæ–‡æœ¬ç±»å‹
					if (item.type === "rtf" && !settings.includeRtf) {
						return false;
					}
					// å›¾ç‰‡ç±»å‹
					if (item.type === "image" && !settings.includeImages) {
						this.addLog(
							"info",
							`ğŸ–¼ï¸ è·³è¿‡å›¾ç‰‡ç±»å‹: ${item.search?.substring(0, 30)}...`,
						);
						return false;
					}
					// æ–‡ä»¶ç±»å‹
					if (item.type === "files" && !settings.includeFiles) {
						this.addLog(
							"info",
							`ğŸ“ è·³è¿‡æ–‡ä»¶ç±»å‹: ${item.search?.substring(0, 30)}...`,
						);
						return false;
					}

					// è®°å½•åŒ…å«çš„æ–‡ä»¶å’Œå›¾ç‰‡ç±»å‹
					if (item.type === "image" || item.type === "files") {
						this.addLog(
							"info",
							`âœ… åŒ…å«${item.type === "image" ? "å›¾ç‰‡" : "æ–‡ä»¶"}ç±»å‹: ${item.search?.substring(0, 30)}...`,
						);
					}

					return true;
				});

				// ç»Ÿè®¡å„ç±»åˆ«æ•°é‡
				const typeStats = {
					text: 0,
					html: 0,
					rtf: 0,
					image: 0,
					files: 0,
				};
				filteredItems.forEach((item) => {
					if (typeStats.hasOwnProperty(item.type)) {
						typeStats[item.type as keyof typeof typeStats]++;
					}
				});

				this.addLog("info", "ğŸ¯ åŒæ­¥æ¨¡å¼è¿‡æ»¤å®Œæˆ", {
					mode: this.syncModeConfig.mode,
					onlyFavorites: settings.onlyFavorites,
					è¿‡æ»¤å‰æ•°é‡: originalCount,
					è¿‡æ»¤åæ•°é‡: filteredItems.length,
					ç±»å‹ç»Ÿè®¡: typeStats,
					åŒ…å«è®¾ç½®: {
						text: settings.includeText,
						html: settings.includeHtml,
						rtf: settings.includeRtf,
						images: settings.includeImages,
						files: settings.includeFiles,
					},
				});
			}

			for (const item of filteredItems) {
				// å…³é”®è°ƒè¯•ï¼šåªåœ¨æ–‡ä»¶ç±»å‹æ—¶è¾“å‡ºè¯¦ç»†ä¿¡æ¯
				if (item.type === "image" || item.type === "files") {
					console.log("=== æ–‡ä»¶é¡¹ç›®æ£€æµ‹ ===", {
						type: item.type,
						search: item.search?.substring(0, 50),
						isFileContentItem: this.isFileContentItem(item)
					});
				}

				this.addLog(
					"info",
					`ğŸ” å¤„ç†é¡¹ç›®: ${item.type} - ${item.search?.substring(0, 30)}...`,
					{
						é¡¹ç›®ID: item.id,
						é¡¹ç›®ç±»å‹: item.type,
						æ˜¯å¦æ–‡ä»¶é¡¹: this.isFileContentItem(item),
						æ˜¯å¦æ–‡æœ¬é¡¹: this.isTextContentItem(item),
					},
				);

				// æ£€æŸ¥æ˜¯å¦éœ€è¦æ–‡ä»¶åŒæ­¥ - æ•°æ®å·²ç»åœ¨å‰é¢è¿‡æ»¤è¿‡äº†ï¼Œè¿™é‡Œç›´æ¥å¤„ç†
				if (this.isFileContentItem(item)) {
					console.log("=== å¼€å§‹æ–‡ä»¶åŒæ­¥å¤„ç† ===", { type: item.type, id: item.id });
					this.addLog("info", "ğŸ“ æ£€æµ‹åˆ°æ–‡ä»¶å†…å®¹é¡¹ï¼Œå¼€å§‹å¤„ç†æ–‡ä»¶åŒæ­¥", {
						é¡¹ç›®ID: item.id,
						é¡¹ç›®ç±»å‹: item.type,
						æœç´¢å†…å®¹: item.search?.substring(0, 50),
					});

					try {
						const processedItem = await this.processFileSyncItem(item);
						if (processedItem) {
							syncItems.push(processedItem);
							this.addLog("success", `âœ… æ–‡ä»¶åŒæ­¥å¤„ç†æˆåŠŸ: ${item.type}`, {
								é¡¹ç›®ID: item.id,
								æ–‡ä»¶è·¯å¾„: processedItem.value,
								æ–‡ä»¶å¤§å°: processedItem.size,
							});
							continue;
						} else {
							this.addLog("error", `âŒ æ–‡ä»¶åŒæ­¥å¤„ç†å¤±è´¥: ${item.type}`);
						}
					} catch (processError) {
						this.addLog("error", `âŒ æ–‡ä»¶åŒæ­¥å¤„ç†å¼‚å¸¸: ${item.type}`, {
							error:
								processError instanceof Error
									? processError.message
									: String(processError),
						});
					}
					continue;
				}

				// åŒæ­¥æ–‡æœ¬ã€å¯Œæ–‡æœ¬ç­‰å†…å®¹
				if (this.isTextContentItem(item)) {
					syncItems.push(this.convertToSyncItem(item));
					this.addLog("info", `ğŸ“ æ–‡æœ¬å†…å®¹é¡¹å·²æ·»åŠ : ${item.type}`);
				} else {
					this.addLog("warning", `âš ï¸ æœªçŸ¥é¡¹ç›®ç±»å‹è·³è¿‡: ${item.type}`, {
						é¡¹ç›®ID: item.id,
						é¡¹ç›®ç±»å‹: item.type,
					});
				}
			}

			if (deletedItems.length > 0) {
				this.addLog("info", "ğŸ—‘ï¸ åŒ…å«åˆ é™¤è®°å½•", { count: deletedItems.length });
			}

			// è®°å½•æœ€ç»ˆåŒæ­¥æ•°æ®ç»Ÿè®¡
			this.addLog("info", "ğŸ“Š åŒæ­¥æ•°æ®ç»Ÿè®¡", {
				åŸå§‹æ•°æ®: localData.length,
				è¿‡æ»¤å: filteredItems.length,
				æœ€ç»ˆåŒæ­¥: syncItems.length,
				åˆ é™¤è®°å½•: deletedItems.length,
			});

			// å®Œæˆåˆ†æ®µç®¡ç†å™¨çš„å½“å‰åˆ†æ®µï¼Œç¡®ä¿æ‰€æœ‰æ–‡ä»¶è¢«æ‰“åŒ…ä¸Šä¼ 
			try {
				await fileSegmentManager.finalizeCurrentSegment(this.config);
				this.addLog("success", "âœ… åˆ†æ®µç®¡ç†å™¨å·²å®Œæˆï¼Œæ–‡ä»¶åˆ†æ®µå·²ä¸Šä¼ åˆ°äº‘ç«¯");
			} catch (segmentError) {
				// åˆ†æ®µç®¡ç†å™¨å®Œæˆå¤±è´¥ï¼Œè®°å½•é”™è¯¯ä½†ç»§ç»­åŒæ­¥
				this.addLog("error", "âŒ åˆ†æ®µç®¡ç†å™¨å®Œæˆå¤±è´¥", {
					error: segmentError instanceof Error ? segmentError.message : String(segmentError),
				});
			}

			return {
				version: 1,
				timestamp: Date.now(),
				deviceId: this.deviceId,
				dataType: "full",
				items: syncItems,
				deleted: deletedItems,
				compression: "none",
				checksum: calculateStringChecksum(JSON.stringify(syncItems)),
			};
		} catch (error) {
			console.error("è½¬æ¢æœ¬åœ°æ•°æ®å¤±è´¥:", error);
			throw error;
		}
	}

	/**
	 * å…¨é‡åŒæ­¥ä¸Šä¼ 
	 */
	async fullSyncUpload(): Promise<SyncResult> {
		// è°ƒè¯•ï¼šåœ¨æ–¹æ³•å¼€å§‹æ—¶æ£€æŸ¥é…ç½®çŠ¶æ€
		this.addLog("info", `ğŸ” fullSyncUploadå¼€å§‹æ—¶é…ç½®æ£€æŸ¥: ${this.config ? 'å­˜åœ¨' : 'ä¸¢å¤±'} - ${this.config?.endpoint || 'undefined'}`);

		if (!this.config) {
			throw new Error("WebDAVé…ç½®æœªåˆå§‹åŒ–");
		}

		const startTime = Date.now();
		const result: SyncResult = {
			success: false,
			uploaded: 0,
			downloaded: 0,
			conflicts: [],
			errors: [],
			duration: 0,
			timestamp: startTime,
		};

		try {
			// 1. è·å–æœ¬åœ°æ•°æ®
			const syncData = await this.convertLocalToSyncDataWithDeleted();

			// è¯¦ç»†åˆ†ææ¯ä¸ªé¡¹ç›®çš„ç±»å‹
			const typeStats = { text: 0, image: 0, files: 0, html: 0, rtf: 0, other: 0 };
			syncData.items.forEach(item => {
				if (typeStats.hasOwnProperty(item.type)) {
					typeStats[item.type as keyof typeof typeStats]++;
				} else {
					typeStats.other++;
				}
			});
			console.log("=== ç±»å‹ç»Ÿè®¡ ===", typeStats);

			// 2. ç›´æ¥ä¸Šä¼ æ–‡ä»¶ï¼ˆä½¿ç”¨ç”¨æˆ·é…ç½®çš„ç›®å½•ï¼‰
			const filePath = this.getFullSyncFilePath();
			this.addLog("info", "â˜ï¸ å¼€å§‹ä¸Šä¼ å…¨é‡åŒæ­¥æ–‡ä»¶", { filePath });

			const uploadResult = await uploadSyncData(
				this.config,
				filePath,
				JSON.stringify(syncData, null, 2),
			);

			if (uploadResult.success) {
				result.uploaded = syncData.items.length;
				result.success = true;

				// æ˜ç¡®è®°å½•å®é™…ä¸Šä¼ çš„é¡¹ç›®æ•°é‡
				this.addLog(
					"success",
					`âœ… å…¨é‡åŒæ­¥ä¸Šä¼ å®Œæˆï¼ŒåŒæ­¥äº† ${syncData.items.length} ä¸ªé¡¹ç›®`,
				);

				// 3. æ›´æ–°å…ƒæ•°æ®
				await this.updateMetadata();
				this.lastSyncTime = Date.now();

				// 4. è§¦å‘ç•Œé¢åˆ·æ–°äº‹ä»¶
				this.addLog("info", "ğŸ”„ è§¦å‘ç•Œé¢åˆ·æ–°äº‹ä»¶");
				triggerSyncEvent();

				// 5. ä½¿ç”¨é¡¹ç›®åŸæœ‰çš„åˆ·æ–°äº‹ä»¶
				this.addLog("info", "ğŸ“¢ å‘é€é¡¹ç›®æ ‡å‡†åˆ·æ–°äº‹ä»¶");
				try {
					emit(LISTEN_KEY.REFRESH_CLIPBOARD_LIST);
					this.addLog("success", "âœ… é¡¹ç›®æ ‡å‡†åˆ·æ–°äº‹ä»¶å‘é€æˆåŠŸ");
				} catch (error) {
					this.addLog("error", "âŒ é¡¹ç›®æ ‡å‡†åˆ·æ–°äº‹ä»¶å‘é€å¤±è´¥", {
						error: error instanceof Error ? error.message : String(error),
					});
				}
			} else {
				result.errors.push(uploadResult.error_message || "ä¸Šä¼ å¤±è´¥");
				// å³ä½¿ä¸Šä¼ å¤±è´¥ä¹Ÿè§¦å‘ç•Œé¢åˆ·æ–°
				try {
					emit(LISTEN_KEY.REFRESH_CLIPBOARD_LIST);
					this.addLog("info", "ğŸ“¢ ä¸Šä¼ å¤±è´¥åè§¦å‘ç•Œé¢åˆ·æ–°");
				} catch (refreshError) {
					this.addLog("error", "âŒ è§¦å‘ç•Œé¢åˆ·æ–°å¤±è´¥", {
						error:
							refreshError instanceof Error
								? refreshError.message
								: String(refreshError),
					});
				}
			}
		} catch (error) {
			result.errors.push(
				error instanceof Error ? error.message : String(error),
			);
			// åŒæ­¥å¼‚å¸¸æ—¶ä¹Ÿè§¦å‘ç•Œé¢åˆ·æ–°
			try {
				emit(LISTEN_KEY.REFRESH_CLIPBOARD_LIST);
				this.addLog("info", "ğŸ“¢ åŒæ­¥å¼‚å¸¸åè§¦å‘ç•Œé¢åˆ·æ–°");
			} catch (refreshError) {
				this.addLog("error", "âŒ è§¦å‘ç•Œé¢åˆ·æ–°å¤±è´¥", {
					error:
						refreshError instanceof Error
							? refreshError.message
							: String(refreshError),
				});
			}
		}

		result.duration = Date.now() - startTime;
		return result;
	}

	/**
	 * å°è¯•æŸ¥æ‰¾æœ€æ–°çš„å¯ç”¨åŒæ­¥æ–‡ä»¶
	 */
	private async findLatestSyncFile(): Promise<string | null> {
		if (!this.config) return null;

		// ç®€åŒ–æ–‡ä»¶ç»“æ„ï¼Œåªä¿ç•™å¿…è¦çš„æ–‡ä»¶
		const possibleFiles = [
			this.getFullPath("sync-data.json"), // ä¸»è¦åŒæ­¥æ–‡ä»¶
			this.getFullPath("metadata.json"), // å…ƒæ•°æ®æ–‡ä»¶
		];

		this.addLog("info", "ğŸ” æœç´¢å¯ç”¨çš„åŒæ­¥æ–‡ä»¶", { possibleFiles });

		for (const filePath of possibleFiles) {
			try {
				this.addLog("info", `ğŸ“¥ å°è¯•ä¸‹è½½æ–‡ä»¶: ${filePath}`);
				const result = await downloadSyncData(this.config, filePath);
				if (result.success && result.data) {
					this.addLog("success", `âœ… æ‰¾åˆ°å¯ç”¨æ–‡ä»¶: ${filePath}`);
					return filePath;
				}
			} catch (error) {
				this.addLog("info", `âŒ æ–‡ä»¶ä¸å¯ç”¨: ${filePath}`, {
					error: error instanceof Error ? error.message : String(error),
				});
			}
		}

		this.addLog("warning", "âš ï¸ æœªæ‰¾åˆ°ä»»ä½•å¯ç”¨çš„åŒæ­¥æ–‡ä»¶ï¼Œå°†åˆ›å»ºæ–°çš„åŒæ­¥æ•°æ®");
		return null;
	}

	/**
	 * å…¨é‡åŒæ­¥ä¸‹è½½
	 */
	async fullSyncDownload(): Promise<SyncResult> {
		this.addLog("info", "ğŸš€ å¼€å§‹å…¨é‡åŒæ­¥ä¸‹è½½", { configExists: !!this.config });

		if (!this.config) {
			this.addLog("error", "âŒ WebDAVé…ç½®æœªåˆå§‹åŒ–");
			throw new Error("WebDAVé…ç½®æœªåˆå§‹åŒ–");
		}

		const startTime = Date.now();
		const result: SyncResult = {
			success: false,
			uploaded: 0,
			downloaded: 0,
			conflicts: [],
			errors: [],
			duration: 0,
			timestamp: startTime,
		};

		try {
			// 1. æŸ¥æ‰¾æœ€æ–°çš„å¯ç”¨åŒæ­¥æ–‡ä»¶
			const filePath = await this.findLatestSyncFile();
			if (!filePath) {
				this.addLog("error", "âŒ æœªæ‰¾åˆ°å¯ç”¨çš„åŒæ­¥æ–‡ä»¶");
				result.errors.push("äº‘ç«¯æ²¡æœ‰å¯ç”¨çš„åŒæ­¥æ•°æ®");
				return result;
			}

			this.addLog("info", "ğŸŒ å¼€å§‹ä¸‹è½½å…¨é‡åŒæ­¥æ–‡ä»¶", { filePath });
			const downloadResult = await downloadSyncData(this.config, filePath);
			this.addLog("info", "ğŸ“¦ æ–‡ä»¶ä¸‹è½½å®Œæˆ", {
				success: downloadResult.success,
				hasData: !!downloadResult.data,
				error: downloadResult.error_message,
			});

			if (downloadResult.success && downloadResult.data) {
				// 2. è§£æåŒæ­¥æ•°æ®
				this.addLog("info", "ğŸ“„ è§£æåŒæ­¥æ•°æ®æˆåŠŸ");
				const syncData: SyncData = JSON.parse(downloadResult.data);

				// 3. è½¬æ¢ä¸ºæœ¬åœ°æ ¼å¼å¹¶å¤„ç†æ–‡ä»¶æ¢å¤
				let localData = [];
				for (const item of syncData.items) {
					const localItem: any = {
						id: item.id,
						type: item.type,
						group: item.group,
						value: item.value,
						search: item.search,
						count: item.count,
						width: item.width,
						height: item.height,
						favorite: item.favorite,
						createTime: item.createTime,
						note: item.note,
						subtype: item.subtype,
					};

					// å¤„ç†å›¾ç‰‡æ–‡ä»¶æ¢å¤
					if (
						item.type === "image" &&
						item.value &&
						!item.value.startsWith("http")
					) {
						if (item._syncType === "segmented_files" && item._segmentReferences) {
							// æ–°çš„åˆ†æ®µå­˜å‚¨æ ¼å¼
							const restoredValue = await this.restoreFilesArrayFromSegments(item);
							if (restoredValue) {
								try {
									const restoredFiles = JSON.parse(restoredValue);
									if (restoredFiles.length > 0) {
										localItem.value = restoredFiles[0].data;
									}
								} catch (parseError) {
									this.addLog("error", "åˆ†æ®µå›¾ç‰‡è§£æå¤±è´¥", { error: parseError });
								}
							}
						} else if (item._syncType === "file_content") {
							// æ—§çš„æ–‡ä»¶æ ¼å¼ï¼ˆå…¼å®¹æ€§ï¼‰
							const restoredPath = await this.restoreFileFromWebDAV(
								item.value,
								`images/${item.id}`,
							);
							if (restoredPath) {
								localItem.value = restoredPath;
							}
						}
					}

					// å¤„ç†æ–‡ä»¶æ•°ç»„æ¢å¤
					if (
						item.type === "files" &&
						item.files &&
						Array.isArray(item.files)
					) {
						// æ£€æŸ¥æ˜¯å¦æ˜¯æ–°çš„åˆ†æ®µå­˜å‚¨æ ¼å¼
						if (item._syncType === "segmented_files" && item._segmentReferences) {
							const restoredValue = await this.restoreFilesArrayFromSegments(item);
							if (restoredValue) {
								try {
									const restoredFiles = JSON.parse(restoredValue);
									localItem.files = restoredFiles;
								} catch (parseError) {
									this.addLog("error", "åˆ†æ®µæ–‡ä»¶è§£æå¤±è´¥", { error: parseError });
									// ä¿ç•™åŸå§‹æ–‡ä»¶ä¿¡æ¯
									localItem.files = item.files;
								}
							} else {
								// æ¢å¤å¤±è´¥ï¼Œä¿ç•™åŸå§‹æ–‡ä»¶ä¿¡æ¯
								localItem.files = item.files;
							}
						} else {
							// ä¼ ç»Ÿæ–‡ä»¶æ¢å¤é€»è¾‘
							const restoredFiles = [];
							for (const file of item.files) {
								if (file.data && file._syncType === "file_content") {
									const restoredPath = await this.restoreFileFromWebDAV(
										file.data,
										`files/${item.id}/${file.name}`,
									);
									if (restoredPath) {
										restoredFiles.push({
											...file,
											data: restoredPath,
										});
									} else {
										restoredFiles.push(file);
									}
								} else {
									restoredFiles.push(file);
								}
							}
							localItem.files = restoredFiles;
						}
					}

					localData.push(localItem);
				}

				// 4. æ ¹æ®åŒæ­¥æ¨¡å¼é…ç½®è¿‡æ»¤ä¸‹è½½çš„æ•°æ®
				if (this.syncModeConfig && this.syncModeConfig.settings) {
					const settings = this.syncModeConfig.settings;
					const originalCount = localData.length;

					this.addLog("info", "ğŸ“¥ å¼€å§‹è¿‡æ»¤ä¸‹è½½çš„æ•°æ®", {
						ä¸‹è½½æ¡æ•°: originalCount,
						æ”¶è—æ¨¡å¼: settings.onlyFavorites,
					});

					// æ”¶è—æ¨¡å¼ï¼šåªå¤„ç†æ”¶è—çš„å†…å®¹
					if (settings.onlyFavorites) {
						localData = localData.filter((item) => {
							const isFavorite = item.favorite === true || item.favorite === 1;
							return isFavorite;
						});
						this.addLog("info", "ğŸ”– æ”¶è—æ¨¡å¼è¿‡æ»¤ä¸‹è½½æ•°æ®", {
							è¿‡æ»¤å‰: originalCount,
							è¿‡æ»¤å: localData.length,
							ä¿ç•™çš„æ”¶è—æ•°é‡: localData.filter(
								(item) => item.favorite === true || item.favorite === 1,
							).length,
						});
					}

					// æ ¹æ®å†…å®¹ç±»å‹è¿‡æ»¤
					localData = localData.filter((item) => {
						// æ–‡æœ¬ç±»å‹
						if (item.type === "text" && !settings.includeText) {
							return false;
						}
						// HTMLç±»å‹
						if (item.type === "html" && !settings.includeHtml) {
							return false;
						}
						// å¯Œæ–‡æœ¬ç±»å‹
						if (item.type === "rtf" && !settings.includeRtf) {
							return false;
						}
						// å›¾ç‰‡ç±»å‹
						if (item.type === "image" && !settings.includeImages) {
							return false;
						}
						// æ–‡ä»¶ç±»å‹
						if (item.type === "files" && !settings.includeFiles) {
							return false;
						}
						return true;
					});

					this.addLog("info", "ğŸ¯ ä¸‹è½½æ•°æ®è¿‡æ»¤å®Œæˆ", {
						mode: this.syncModeConfig.mode,
						onlyFavorites: settings.onlyFavorites,
						æœ€ç»ˆæ¡æ•°: localData.length,
						è¿‡æ»¤è®¾ç½®: {
							text: settings.includeText,
							html: settings.includeHtml,
							rtf: settings.includeRtf,
							images: settings.includeImages,
							files: settings.includeFiles,
						},
					});
				}

				this.addLog("info", `ğŸ’¾ å‡†å¤‡å¯¼å…¥ ${localData.length} æ¡æ•°æ®åˆ°æ•°æ®åº“`);
				this.addLog("info", "ğŸ“‹ æ•°æ®æ ·æœ¬", { sample: localData.slice(0, 2) });

				// ç¡®ä¿æ•°æ®åº“æ—¥å¿—å›è°ƒå·²è®¾ç½®
				if (this.logCallback) {
					setImportLogCallback((message, data) => {
						this.logCallback!("info", `ğŸ’¾ ${message}`, data);
					});
				}

				this.addLog("info", "ğŸ”„ å¼€å§‹æ™ºèƒ½åˆå¹¶æ•°æ®");
				await this.mergeHistoryData(localData);
				this.addLog("success", "âœ… æ™ºèƒ½åˆå¹¶å®Œæˆ");
				result.downloaded = syncData.items.length;
				result.success = true;

				// 4. æ›´æ–°å…ƒæ•°æ®
				await this.updateMetadata();
				this.lastSyncTime = Date.now();

				// 5. çŸ­æš‚å»¶è¿Ÿç¡®ä¿æ•°æ®å†™å…¥å®Œæˆ
				await new Promise((resolve) => setTimeout(resolve, 100));

				// 6. è§¦å‘ç•Œé¢åˆ·æ–°äº‹ä»¶
				this.addLog("success", "ğŸ”„ è§¦å‘ç•Œé¢åˆ·æ–°äº‹ä»¶");
				triggerSyncEvent();

				// 7. ä½¿ç”¨é¡¹ç›®åŸæœ‰çš„åˆ·æ–°äº‹ä»¶
				this.addLog("info", "ğŸ“¢ å‘é€é¡¹ç›®æ ‡å‡†åˆ·æ–°äº‹ä»¶");
				try {
					emit(LISTEN_KEY.REFRESH_CLIPBOARD_LIST);
					this.addLog("success", "âœ… é¡¹ç›®æ ‡å‡†åˆ·æ–°äº‹ä»¶å‘é€æˆåŠŸ");
				} catch (error) {
					this.addLog("error", "âŒ é¡¹ç›®æ ‡å‡†åˆ·æ–°äº‹ä»¶å‘é€å¤±è´¥", {
						error: error instanceof Error ? error.message : String(error),
					});
				}
			} else {
				this.addLog("error", "âŒ æ•°æ®ä¸‹è½½å¤±è´¥", {
					error: downloadResult.error_message,
				});
				result.errors.push(downloadResult.error_message || "ä¸‹è½½å¤±è´¥");
			}
		} catch (error) {
			result.errors.push(
				error instanceof Error ? error.message : String(error),
			);
		}

		result.duration = Date.now() - startTime;
		return result;
	}

	/**
	 * æ›´æ–°åŒæ­¥å…ƒæ•°æ®
	 */
	private async updateMetadata(): Promise<void> {
		if (!this.config) return;

		const metadata: SyncMetadata = {
			lastSyncTime: Date.now(),
			deviceId: this.deviceId,
			syncVersion: 1,
			conflictResolution: "merge",
			networkQuality: "medium",
			performanceMetrics: {
				avgUploadSpeed: 0,
				avgDownloadSpeed: 0,
				avgLatency: 0,
			},
		};

		const filePath = this.getMetadataFilePath();
		await uploadSyncData(
			this.config,
			filePath,
			JSON.stringify(metadata, null, 2),
		).catch((error) => {
			console.error("æ›´æ–°å…ƒæ•°æ®å¤±è´¥:", error);
		});
	}

	/**
	 * è·å–åŒæ­¥çŠ¶æ€
	 */
	getSyncStatus() {
		return {
			isOnline: this.isOnline,
			isSyncing: false,
			lastSyncTime: this.lastSyncTime,
			pendingCount: 0,
			errorCount: 0,
			syncProgress: 0,
		};
	}

	/**
	 * ç›´æ¥å¯¼å…¥å†å²æ•°æ®ï¼ˆå‚è€ƒå¤‡ä»½ç³»ç»Ÿé€»è¾‘ï¼‰
	 */
	// private async importHistoryDataDirect(data: any[]) {
	// 	this.addLog("info", "ğŸ”„ ä½¿ç”¨ç›´æ¥å¯¼å…¥æ–¹å¼");

	// 	try {
	// 		// 1. å…³é—­æ•°æ®åº“è¿æ¥
	// 		this.addLog("info", "ğŸ”’ å…³é—­æ•°æ®åº“è¿æ¥");
	// 		emit(LISTEN_KEY.CLOSE_DATABASE);

	// 		// 2. ç”Ÿæˆ SQL è¯­å¥æ¥é‡å»ºæ•°æ®åº“
	// 		const sqlStatements = [
	// 			"DELETE FROM history;",
	// 			...data.map((item) => {
	// 				const fields = Object.keys(item);
	// 				const values = Object.values(item);
	// 				const placeholders = values.map(() => "?").join(", ");
	// 				const sql = `INSERT INTO history (${fields.join(", ")}) VALUES (${placeholders});`;
	// 				return { sql, values };
	// 			}),
	// 		];

	// 		this.addLog("info", `ğŸ“ ç”Ÿæˆäº† ${sqlStatements.length} æ¡ SQL è¯­å¥`);

	// 		// 3. å°†æ•°æ®å†™å…¥ä¸´æ—¶ SQL æ–‡ä»¶
	// 		const dbPath = await getSaveDatabasePath();
	// 		const tempSqlPath = dbPath.replace(".db", "_temp.sql");

	// 		let sqlContent = "";
	// 		for (const statement of sqlStatements) {
	// 			if (typeof statement === "string") {
	// 				sqlContent += `${statement}\n`;
	// 			} else {
	// 				sqlContent += `${statement.sql}\n`;
	// 			}
	// 		}

	// 		await writeTextFile(tempSqlPath, sqlContent);
	// 		this.addLog("success", "âœ… SQL æ–‡ä»¶ç”ŸæˆæˆåŠŸ");

	// 		// 4. ä½¿ç”¨æ™ºèƒ½åˆå¹¶è€Œä¸æ˜¯æ¸…ç©ºé‡å»º
	// 		await this.mergeHistoryData(data);

	// 		this.addLog("success", "âœ… æ•°æ®å¯¼å…¥å®Œæˆ");
	// 	} catch (error) {
	// 		this.addLog("error", "âŒ ç›´æ¥å¯¼å…¥å¤±è´¥", {
	// 			error: error instanceof Error ? error.message : String(error),
	// 		});
	// 		throw error;
	// 	}
	// }

	/**
	 * è·å–äº‘ç«¯æ•°æ®ä½†ä¸æ›¿æ¢æœ¬åœ°æ•°æ®
	 */
	async fetchCloudDataOnly(): Promise<{
		items: SyncItem[];
		deleted: string[];
	} | null> {
		if (!this.config) {
			this.addLog("error", "âŒ WebDAVé…ç½®æœªåˆå§‹åŒ–");
			return null;
		}

		try {
			// 1. æŸ¥æ‰¾æœ€æ–°çš„å¯ç”¨åŒæ­¥æ–‡ä»¶
			const filePath = await this.findLatestSyncFile();
			if (!filePath) {
				this.addLog("info", "â„¹ï¸ äº‘ç«¯æ²¡æœ‰å¯ç”¨çš„åŒæ­¥æ•°æ®");
				return null;
			}

			this.addLog("info", "ğŸŒ å¼€å§‹è·å–äº‘ç«¯åŒæ­¥æ–‡ä»¶", { filePath });
			const downloadResult = await downloadSyncData(this.config, filePath);

			if (downloadResult.success && downloadResult.data) {
				// 2. è§£æåŒæ­¥æ•°æ®
				this.addLog("info", "ğŸ“„ è§£æäº‘ç«¯åŒæ­¥æ•°æ®æˆåŠŸ");
				const syncData: SyncData = JSON.parse(downloadResult.data);

				this.addLog(
					"info",
					`âœ… è·å–åˆ°äº‘ç«¯æ•°æ® ${syncData.items.length} æ¡ï¼Œåˆ é™¤è®°å½• ${syncData.deleted?.length || 0} æ¡`,
				);

				return {
					items: syncData.items,
					deleted: syncData.deleted || [],
				};
			}

			this.addLog("error", "âŒ è·å–äº‘ç«¯æ•°æ®å¤±è´¥", {
				error: downloadResult.error_message,
			});
			return null;
		} catch (error) {
			this.addLog("error", "âŒ è·å–äº‘ç«¯æ•°æ®å¼‚å¸¸", {
				error: error instanceof Error ? error.message : String(error),
			});
			return null;
		}
	}

	/**
	 * æ™ºèƒ½åˆå¹¶äº‘ç«¯æ•°æ®å’Œæœ¬åœ°æ•°æ®
	 */
	async mergeCloudAndLocalData(cloudItems: SyncItem[]): Promise<void> {
		try {
			this.addLog("info", "ğŸ”„ å¼€å§‹æ™ºèƒ½åˆå¹¶äº‘ç«¯å’Œæœ¬åœ°æ•°æ®");

			// 1. è·å–æœ¬åœ°æ•°æ®
			const localData = await getHistoryData();
			this.addLog(
				"info",
				`ğŸ“Š æœ¬åœ°æ•°æ® ${(localData as any[]).length} æ¡ï¼Œäº‘ç«¯æ•°æ® ${cloudItems.length} æ¡`,
			);

			// 2. åˆ›å»ºåˆå¹¶ç­–ç•¥
			const mergedItems = new Map<string, any>();
			const conflicts: string[] = [];

			// 3. é¦–å…ˆæ·»åŠ æœ¬åœ°æ•°æ®
			for (const item of localData as any[]) {
				mergedItems.set(item.id, item);
			}

			// 4. åˆå¹¶äº‘ç«¯æ•°æ®ï¼ˆæ™ºèƒ½ç­–ç•¥ï¼‰
			for (const cloudItem of cloudItems) {
				const localItem = mergedItems.get(cloudItem.id);

				if (!localItem) {
					// æœ¬åœ°æ²¡æœ‰ï¼Œç›´æ¥æ·»åŠ äº‘ç«¯æ•°æ®
					mergedItems.set(cloudItem.id, {
						id: cloudItem.id,
						type: cloudItem.type,
						group: cloudItem.group,
						value: cloudItem.value,
						search: cloudItem.search,
						count: cloudItem.count,
						width: cloudItem.width,
						height: cloudItem.height,
						favorite: cloudItem.favorite,
						createTime: cloudItem.createTime,
						note: cloudItem.note,
						subtype: cloudItem.subtype,
					});
					this.addLog(
						"info",
						`â• æ·»åŠ äº‘ç«¯æ–°æ•°æ®: ${cloudItem.type} - ${cloudItem.search?.substring(0, 20)}...`,
					);
				} else {
					// æœ¬åœ°å’Œäº‘ç«¯éƒ½æœ‰ï¼Œè¿›è¡Œå†²çªè§£å†³
					const cloudTime = new Date(cloudItem.createTime).getTime();
					const localTime = new Date((localItem as any).createTime).getTime();

					if (cloudTime > localTime) {
						// äº‘ç«¯æ•°æ®æ›´æ–°ï¼Œä½¿ç”¨äº‘ç«¯æ•°æ®
						mergedItems.set(cloudItem.id, {
							id: cloudItem.id,
							type: cloudItem.type,
							group: cloudItem.group,
							value: cloudItem.value,
							search: cloudItem.search,
							count: cloudItem.count,
							width: cloudItem.width,
							height: cloudItem.height,
							favorite: cloudItem.favorite,
							createTime: cloudItem.createTime,
							note: cloudItem.note,
							subtype: cloudItem.subtype,
						});
						conflicts.push(cloudItem.id);
						this.addLog(
							"info",
							`ğŸ”„ ä½¿ç”¨æ›´æ–°çš„äº‘ç«¯æ•°æ®: ${cloudItem.type} - ${cloudItem.search?.substring(0, 20)}...`,
						);
					} else {
						// æœ¬åœ°æ•°æ®æ›´æ–°æˆ–ç›¸åŒï¼Œä¿ç•™æœ¬åœ°æ•°æ®
						this.addLog(
							"info",
							`âœ… ä¿ç•™æœ¬åœ°æ•°æ®: ${(localItem as any).type} - ${(localItem as any).search?.substring(0, 20)}...`,
						);
					}
				}
			}

			// 5. ä¿å­˜åˆå¹¶åçš„æ•°æ®
			const mergedArray = Array.from(mergedItems.values());
			this.addLog(
				"info",
				`ğŸ’¾ ä¿å­˜åˆå¹¶åçš„æ•°æ® ${mergedArray.length} æ¡ï¼Œè§£å†³äº† ${conflicts.length} ä¸ªå†²çª`,
			);

			// è®¾ç½®æ•°æ®åº“å¯¼å…¥æ—¥å¿—å›è°ƒ
			if (this.logCallback) {
				setImportLogCallback((message, data) => {
					this.logCallback!("info", `ğŸ’¾ ${message}`, data);
				});
			}

			await this.mergeHistoryData(mergedArray);
			this.addLog("success", "âœ… æ•°æ®åˆå¹¶å®Œæˆ");
		} catch (error) {
			this.addLog("error", "âŒ åˆå¹¶æ•°æ®å¤±è´¥", {
				error: error instanceof Error ? error.message : String(error),
			});
			throw error;
		}
	}

	/**
	 * æ™ºèƒ½åˆå¹¶å†å²æ•°æ®ï¼ˆä¸æ¸…ç©ºç°æœ‰æ•°æ®ï¼‰
	 */
	private async mergeHistoryData(newData: any[]): Promise<void> {
		if (!this.config) return;

		try {
			this.addLog("info", `ğŸ”„ å¼€å§‹æ™ºèƒ½åˆå¹¶ ${newData.length} æ¡æ•°æ®`);

			// è·å–ç°æœ‰æ•°æ®
			const existingData = await getHistoryData();
			const existingMap = new Map(
				(existingData as any[]).map((item: any) => [item.id, item]),
			);
			const newMap = new Map(newData.map((item: any) => [item.id, item]));

			let addedCount = 0;
			let updatedCount = 0;

			// 1. æ·»åŠ æ–°æ•°æ®
			for (const [id, item] of newMap) {
				if (!existingMap.has(id)) {
					// å¤„ç†æŒ‰éœ€ä¸‹è½½é¡¹ç›®çš„æ•°æ®æ¢å¤
					const processedItem = await this.processLazyDownloadItem(item);
					await this.insertForSync("history", processedItem);
					addedCount++;
				}
			}

			// 2. æ›´æ–°ç°æœ‰æ•°æ®ï¼ˆå¦‚æœæ—¶é—´æˆ³ä¸åŒï¼‰
			for (const [id, newItem] of newMap) {
				const existingItem = existingMap.get(id);
				if (existingItem) {
					const newTime = new Date(newItem.createTime).getTime();
					const existingTime = new Date(
						(existingItem as any).createTime,
					).getTime();

					if (newTime !== existingTime) {
						// å¤„ç†æŒ‰éœ€ä¸‹è½½é¡¹ç›®çš„æ•°æ®æ¢å¤
						const processedItem = await this.processLazyDownloadItem(newItem);
						// æ›´æ–°æ•°æ®ï¼Œä½†ä¿ç•™é‡è¦å­—æ®µå¦‚æ”¶è—çŠ¶æ€
						const updateItem = {
							...processedItem,
							favorite: (existingItem as any).favorite, // ä¿ç•™åŸæœ‰çš„æ”¶è—çŠ¶æ€
						};
						await updateSQL("history", updateItem);
						updatedCount++;
					}
				}
			}

			// 3. åˆ é™¤åœ¨æ–°æ•°æ®ä¸­ä¸å­˜åœ¨çš„ç°æœ‰æ•°æ®ï¼ˆå¯é€‰ï¼‰
			// è¿™é‡Œä¸åˆ é™¤ï¼Œä¿æŒæ•°æ®å®Œæ•´æ€§

			this.addLog(
				"success",
				`âœ… æ™ºèƒ½åˆå¹¶å®Œæˆï¼šæ–°å¢ ${addedCount} æ¡ï¼Œæ›´æ–° ${updatedCount} æ¡`,
			);
		} catch (error) {
			this.addLog("error", "âŒ æ™ºèƒ½åˆå¹¶å¤±è´¥", {
				error: error instanceof Error ? error.message : String(error),
			});
			throw error;
		}
	}

	/**
	 * å¤„ç†æŒ‰éœ€ä¸‹è½½é¡¹ç›®çš„æ•°æ®æ¢å¤
	 */
	private async processLazyDownloadItem(item: any): Promise<any> {
		try {
			// å¦‚æœä¸æ˜¯æŒ‰éœ€ä¸‹è½½é¡¹ç›®ï¼Œç›´æ¥è¿”å›
			if (!item.lazyDownload) {
				return item;
			}

			// æ£€æŸ¥æ˜¯å¦ä¸ºæ–‡ä»¶ç±»å‹
			if (item.type === "image" || item.type === "files") {
				this.addLog(
					"info",
					`ğŸ”„ å¤„ç†æŒ‰éœ€ä¸‹è½½é¡¹ç›®: ${item.type} - ${item.search?.substring(0, 20)}...`,
				);

				// è½¬æ¢ä¸ºSyncItemæ ¼å¼
				const syncItem: SyncItem = {
					id: item.id,
					type: item.type,
					group: item.group,
					value: item.value,
					search: item.search,
					count: item.count,
					width: item.width,
					height: item.height,
					favorite: item.favorite,
					createTime: item.createTime,
					note: item.note,
					subtype: item.subtype,
					lazyDownload: item.lazyDownload,
					fileSize: item.fileSize,
					fileType: item.fileType,
				} as SyncItem;

				// è·å–æ–‡ä»¶çŠ¶æ€ä¿¡æ¯
				const fileStatus = fileContentProcessor.getFileStatus(syncItem);

				this.addLog("info", "ğŸ“Š æ–‡ä»¶çŠ¶æ€ä¿¡æ¯", {
					isLazyDownload: fileStatus.isLazyDownload,
					isAvailable: fileStatus.isAvailable,
					fileSize: fileStatus.fileSize,
					fileType: fileStatus.fileType,
				});

				// å¦‚æœæ–‡ä»¶ä¸å¯ç”¨ä¸”æ˜¯æŒ‰éœ€ä¸‹è½½ï¼Œä¿ç•™åŸå§‹valueï¼ˆWebDAVè·¯å¾„ï¼‰
				// è¿™æ ·åœ¨ç”¨æˆ·éœ€è¦æ—¶å¯ä»¥è§¦å‘ä¸‹è½½
				if (fileStatus.isLazyDownload && !fileStatus.isAvailable) {
					this.addLog(
						"info",
						`ğŸ“¥ æŒ‰éœ€ä¸‹è½½æ–‡ä»¶æš‚æœªç¼“å­˜ï¼Œä¿ç•™äº‘ç«¯å¼•ç”¨: ${item.value}`,
					);
					return item; // ä¿æŒåŸå§‹valueä¸å˜
				}
			}

			// å¯¹äºéæŒ‰éœ€ä¸‹è½½æ–‡ä»¶æˆ–å·²ç¼“å­˜çš„æ–‡ä»¶ï¼Œç›´æ¥è¿”å›
			return item;
		} catch (error) {
			this.addLog("error", "âŒ å¤„ç†æŒ‰éœ€ä¸‹è½½é¡¹ç›®å¤±è´¥", {
				error: error instanceof Error ? error.message : String(error),
				itemId: item.id,
			});
			return item; // å¤±è´¥æ—¶è¿”å›åŸå§‹é¡¹ç›®
		}
	}

	// åˆ¤æ–­æ˜¯å¦ä¸ºæ–‡ä»¶å†…å®¹é¡¹
	private isFileContentItem(item: any): boolean {
		const isFile = item.type === "image" || item.type === "files";

		if (isFile) {
			this.addLog("info", `ğŸ¯ æ£€æµ‹åˆ°æ–‡ä»¶å†…å®¹é¡¹: ${item.type}`, {
				itemId: item.id,
				itemType: item.type,
				search: item.search?.substring(0, 30),
				value: item.value?.substring(0, 50),
			});
		}
		return isFile;
	}

	// åˆ¤æ–­æ˜¯å¦ä¸ºæ–‡æœ¬å†…å®¹é¡¹
	private isTextContentItem(item: any): boolean {
		return item.type === "text" || item.type === "rtf" || item.type === "html";
	}

	// è½¬æ¢ä¸ºSyncItemï¼ˆç”¨äºæ–‡æœ¬å†…å®¹ï¼‰
	private convertToSyncItem(item: any): SyncItem {
		return {
			id: item.id,
			type: item.type as any,
			group: item.group as any,
			value: item.value,
			search: item.search,
			count: item.count,
			width: item.width,
			height: item.height,
			favorite: item.favorite,
			createTime: item.createTime,
			note: item.note,
			subtype: item.subtype,
			lastModified: Date.now(),
			deviceId: this.deviceId,
			size: JSON.stringify(item).length,
			checksum: calculateStringChecksum(item.value),
		};
	}

	// å¤„ç†æ–‡ä»¶åŒæ­¥é¡¹ï¼ˆç»Ÿä¸€ä½¿ç”¨åˆ†æ®µå­˜å‚¨ï¼‰
	private async processFileSyncItem(item: any): Promise<SyncItem | null> {
		try {
			this.addLog(
				"info",
				`ğŸ”„ å¼€å§‹å¤„ç†æ–‡ä»¶åŒæ­¥é¡¹: ${item.type} - ${item.search?.substring(0, 30)}...`,
			);

			if (item.type === "image") {
				return await this.processImageFileZip(item);
			}
			if (item.type === "files") {
				return await this.processFilesArray(item);
			}

			return this.convertToSyncItem(item);
		} catch (error) {
			this.addLog("error", "æ–‡ä»¶åŒæ­¥å¤„ç†å¤±è´¥", { error, item });
			return this.convertToSyncItem(item); // å¤±è´¥æ—¶å›é€€åˆ°æ–‡æœ¬åŒæ­¥
		}
	}

	// å¤„ç†å›¾ç‰‡æ–‡ä»¶ï¼ˆä½¿ç”¨ZIPå‹ç¼©åŒ…å­˜å‚¨ï¼‰
	private async processImageFileZip(item: any): Promise<SyncItem | null> {
		try {
			this.addLog(
				"info",
				`ğŸ–¼ï¸ å¼€å§‹å¤„ç†å›¾ç‰‡æ–‡ä»¶ï¼ˆZIPå­˜å‚¨ï¼‰: ${item.type} - ${item.search?.substring(0, 30)}...`,
			);

			// ä¿®å¤ï¼šç›´æ¥ä½¿ç”¨åŸå§‹æ–‡ä»¶è·¯å¾„ï¼Œé¿å…é”™è¯¯çš„è·¯å¾„æ‹¼æ¥
			const imagePath = item.value;
			this.addLog("info", `ğŸ“‚ ä½¿ç”¨åŸå§‹å›¾ç‰‡è·¯å¾„: ${imagePath}`);

			// æ£€æŸ¥æ–‡ä»¶å¤§å°
			const fileSize = await this.getFileSize(imagePath);
			const maxFileSize = 10 * 1024 * 1024; // 10MBé™åˆ¶

			this.addLog(
				"info",
				`ğŸ“ å›¾ç‰‡æ–‡ä»¶å¤§å°: ${(fileSize / 1024 / 1024).toFixed(2)}MB, é™åˆ¶: 10MB`,
			);

			if (fileSize > maxFileSize) {
				this.addLog(
					"warning",
					`å›¾ç‰‡æ–‡ä»¶è¿‡å¤§è·³è¿‡åŒæ­¥: ${imagePath} (${(fileSize / 1024 / 1024).toFixed(2)}MB)`,
				);
				return this.convertToSyncItem(item);
			}

			// å‹ç¼©å›¾ç‰‡
			this.addLog("info", `ğŸ—œï¸ å¼€å§‹å‹ç¼©å›¾ç‰‡...`);
			const compressedData = await fileContentProcessor.compressImage(imagePath);
			this.addLog("success", `å›¾ç‰‡å‹ç¼©æˆåŠŸï¼Œå‹ç¼©åå¤§å°: ${(compressedData.byteLength / 1024).toFixed(2)}KB`);

			// æ·»åŠ åˆ°ZIPæ–‡ä»¶ç®¡ç†å™¨
			const result = await zipFileManager.addFile(
				imagePath,
				compressedData,
				item.type,
				this.config!,
			);

			this.addLog("success", `å›¾ç‰‡å·²æ·»åŠ åˆ°ZIPåŒ…: ${imagePath} -> ${result.zipName}`);

			// åˆ›å»ºåŒ…å«ZIPä¿¡æ¯çš„åŒæ­¥é¡¹
			const syncItem: SyncItem = {
				id: item.id,
				type: item.type,
				group: item.group,
				value: JSON.stringify([{
					originalPath: imagePath,
					fileInfo: result.fileInfo,
					zipName: result.zipName,
					originalSize: fileSize,
					compressedSize: compressedData.byteLength,
				}]),
				search: item.search,
				count: item.count,
				width: item.width,
				height: item.height,
				favorite: item.favorite,
				createTime: item.createTime,
				note: item.note,
				subtype: item.subtype,
				_syncType: "zip_files", // æ ‡è®°ä¸ºZIPæ–‡ä»¶æ¨¡å¼
			};

			this.addLog("success", `âœ… ZIPå›¾ç‰‡æ–‡ä»¶å¤„ç†æˆåŠŸ: ${imagePath}`);
			return syncItem;
		} catch (error) {
			this.addLog("error", `âŒ ZIPå›¾ç‰‡æ–‡ä»¶å¤„ç†å¤±è´¥: ${item.value}`, {
				error: error instanceof Error ? error.message : String(error),
			});
			return this.convertToSyncItem(item); // å¤±è´¥æ—¶å›é€€åˆ°æ™®é€šæ¨¡å¼
		}
	}
		try {
			this.addLog(
				"info",
				`ğŸ–¼ï¸ å¼€å§‹å¤„ç†å›¾ç‰‡æ–‡ä»¶ï¼ˆåˆ†æ®µå­˜å‚¨ï¼‰: ${item.type} - ${item.search?.substring(0, 30)}...`,
			);

			// ä¿®å¤ï¼šç›´æ¥ä½¿ç”¨åŸå§‹æ–‡ä»¶è·¯å¾„ï¼Œé¿å…é”™è¯¯çš„è·¯å¾„æ‹¼æ¥
			const imagePath = item.value;
			this.addLog("info", `ğŸ“‚ ä½¿ç”¨åŸå§‹å›¾ç‰‡è·¯å¾„: ${imagePath}`);

			// æ£€æŸ¥æ–‡ä»¶å¤§å°
			const fileSize = await this.getFileSize(imagePath);
			const maxFileSize = 10 * 1024 * 1024; // 10MBé™åˆ¶

			this.addLog(
				"info",
				`ğŸ“ å›¾ç‰‡æ–‡ä»¶å¤§å°: ${(fileSize / 1024 / 1024).toFixed(2)}MB, é™åˆ¶: 10MB`,
			);

			if (fileSize > maxFileSize) {
				this.addLog(
					"warning",
					`å›¾ç‰‡æ–‡ä»¶è¿‡å¤§è·³è¿‡åŒæ­¥: ${imagePath} (${(fileSize / 1024 / 1024).toFixed(2)}MB)`,
				);
				return this.convertToSyncItem(item);
			}

			// å‹ç¼©å›¾ç‰‡å†…å®¹
			this.addLog("info", "ğŸ—œï¸ å¼€å§‹å‹ç¼©å›¾ç‰‡...");
			let compressedContent: ArrayBuffer;
			try {
				compressedContent = await this.fileProcessor.compressImage(imagePath);
				this.addLog(
					"success",
					`å›¾ç‰‡å‹ç¼©æˆåŠŸï¼Œå‹ç¼©åå¤§å°: ${(compressedContent.byteLength / 1024).toFixed(2)}KB`,
				);
			} catch (compressError) {
				this.addLog("error", "å›¾ç‰‡å‹ç¼©å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨åŸå§‹æ–‡ä»¶", {
					error: compressError,
				});
				const { readFile } = await import("@tauri-apps/plugin-fs");
				compressedContent = await readFile(imagePath);
			}

			// ä½¿ç”¨åˆ†æ®µç®¡ç†å™¨å¤„ç†å•ä¸ªå›¾ç‰‡æ–‡ä»¶
			const fileName = imagePath.split(/[\\/]/).pop() || "image";
			const fileType = this.getFileType(imagePath);

			const segmentResult = await fileSegmentManager.addFile(
				imagePath,
				compressedContent,
				fileType,
				this.config,
			);

			this.addLog(
				"success",
				`å›¾ç‰‡å·²æ·»åŠ åˆ°åˆ†æ®µ: ${imagePath} -> ${segmentResult.segmentId}`,
			);

			// æ„å»ºåˆ†æ®µå¼•ç”¨ä¿¡æ¯
			const segmentReferences = [{
				originalPath: imagePath,
				segmentId: segmentResult.segmentId,
				fileIndex: segmentResult.fileIndex,
				originalSize: fileSize,
				compressedSize: compressedContent.byteLength,
			}];

			// è¿”å›åˆ†æ®µå­˜å‚¨çš„åŒæ­¥é¡¹
			const syncItem = {
				...this.convertToSyncItem(item),
				value: JSON.stringify(segmentReferences), // å­˜å‚¨åˆ†æ®µå¼•ç”¨è€Œéç›´æ¥è·¯å¾„
				_syncType: "segmented_files", // ä½¿ç”¨ç›¸åŒçš„åˆ†æ®µå­˜å‚¨æ ‡è¯†
				_segmentReferences: segmentReferences, // ä¿ç•™å®Œæ•´ä¿¡æ¯ç”¨äºæ¢å¤
				lazyDownload: true,
				fileSize: fileSize,
				fileType: "image",
			} as SyncItem;

			this.addLog("success", `å›¾ç‰‡æ–‡ä»¶å¤„ç†å®Œæˆ: ${imagePath}`);
			return syncItem;
		} catch (error) {
			this.addLog("error", "å›¾ç‰‡æ–‡ä»¶åˆ†æ®µå¤„ç†å¤±è´¥ï¼Œå›é€€åˆ°åŸºæœ¬åŒæ­¥", {
				error: error instanceof Error ? error.message : String(error),
				item: { type: item.type, search: item.search?.substring(0, 30) },
			});
			return this.convertToSyncItem(item);
		}
	}

	// å¤„ç†æ–‡ä»¶æ•°ç»„ï¼ˆåˆ†æ®µå­˜å‚¨ç‰ˆæœ¬ï¼‰
	private async processFilesArray(item: any): Promise<SyncItem | null> {
		try {
			this.addLog(
				"info",
				`ğŸš€ å¼€å§‹å¤„ç†æ–‡ä»¶æ•°ç»„ï¼ˆåˆ†æ®µå­˜å‚¨ï¼‰: ${item.type} - ${item.search?.substring(0, 30)}...`,
			);
			this.addLog("info", `ğŸ” é…ç½®çŠ¶æ€æ£€æŸ¥: ${this.config ? 'å·²é…ç½®' : 'æœªé…ç½®'}`);
			this.addLog("info", `ğŸ“¦ item.valueå†…å®¹: ${item.value?.substring(0, 100)}...`);

			let filePaths: string[];
			try {
				filePaths = JSON.parse(item.value);
				this.addLog("info", `è§£æåˆ° ${filePaths.length} ä¸ªæ–‡ä»¶è·¯å¾„`);
			} catch (parseError) {
				this.addLog("error", "æ–‡ä»¶è·¯å¾„JSONè§£æå¤±è´¥", { error: parseError });
				return this.convertToSyncItem(item);
			}

			const maxFileSize = 10 * 1024 * 1024; // 10MBé™åˆ¶
			const segmentFiles: Array<{
				originalPath: string;
				segmentId: string;
				fileIndex: any;
				originalSize: number;
				compressedSize: number;
			}> = [];

			// å¤„ç†æ¯ä¸ªæ–‡ä»¶
			for (let i = 0; i < filePaths.length; i++) {
				const filePath = filePaths[i];
				this.addLog("info", `å¤„ç†æ–‡ä»¶ ${i + 1}/${filePaths.length}: ${filePath}`);

				// æ£€æŸ¥æ–‡ä»¶ç±»å‹
				if (!this.isSupportedFileType(filePath)) {
					this.addLog("info", `ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹ï¼Œè·³è¿‡: ${filePath}`);
					continue;
				}

				// æ£€æŸ¥æ–‡ä»¶å¤§å°
				const fileSize = await this.getFileSize(filePath);
				if (fileSize > maxFileSize) {
					this.addLog(
						"warning",
						`æ–‡ä»¶è¿‡å¤§è·³è¿‡åŒæ­¥: ${filePath} (${(fileSize / 1024 / 1024).toFixed(2)}MB)`,
					);
					continue;
				}

				// æ£€æŸ¥æ–‡ä»¶ç±»å‹æ˜¯å¦æ”¯æŒ
				const fileType = this.getFileType(filePath);
				if (!globalStore.cloudSync.fileSync.supportedTypes[fileType]) {
					this.addLog("info", `${fileType}ç±»å‹æœªå¼€å¯åŒæ­¥ï¼Œè·³è¿‡: ${filePath}`);
					continue;
				}

				// å‹ç¼©æ–‡ä»¶
				this.addLog("info", `å¼€å§‹å‹ç¼©æ–‡ä»¶: ${filePath}`);
				let compressedContent: ArrayBuffer;
				try {
					compressedContent = await this.fileProcessor.compressFile(filePath);
					this.addLog("success", `æ–‡ä»¶å‹ç¼©æˆåŠŸ: ${filePath}`);
				} catch (compressError) {
					this.addLog("error", "æ–‡ä»¶å‹ç¼©å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨åŸå§‹æ–‡ä»¶", {
						error: compressError,
						filePath,
					});
					const { readFile } = await import("@tauri-apps/plugin-fs");
					compressedContent = await readFile(filePath);
				}

				// ä½¿ç”¨åˆ†æ®µç®¡ç†å™¨æ·»åŠ æ–‡ä»¶
				const segmentResult = await fileSegmentManager.addFile(
					filePath,
					compressedContent,
					fileType,
					this.config,
				);

				segmentFiles.push({
					originalPath: filePath,
					segmentId: segmentResult.segmentId,
					fileIndex: segmentResult.fileIndex,
					originalSize: fileSize,
					compressedSize: compressedContent.byteLength,
				});

				this.addLog(
					"success",
					`æ–‡ä»¶å·²æ·»åŠ åˆ°åˆ†æ®µ: ${filePath} -> ${segmentResult.segmentId}`,
				);
			}

			if (segmentFiles.length === 0) {
				this.addLog("warning", "æ²¡æœ‰æˆåŠŸå¤„ç†çš„æ–‡ä»¶ï¼Œå›é€€åˆ°åŸºæœ¬åŒæ­¥");
				return this.convertToSyncItem(item);
			}

			this.addLog(
				"success",
				`æ–‡ä»¶æ•°ç»„å¤„ç†å®Œæˆï¼ŒæˆåŠŸå¤„ç† ${segmentFiles.length} ä¸ªæ–‡ä»¶`,
			);

			// å®Œæˆåˆ†æ®µç®¡ç†å™¨çš„å½“å‰åˆ†æ®µ
			await fileSegmentManager.finalizeCurrentSegment(this.config);

			// å®ŒæˆZIPæ–‡ä»¶ç®¡ç†å™¨çš„å½“å‰ZIPåŒ…
			await zipFileManager.finalizeCurrentZip(this.config);

			// æ„å»ºåˆ†æ®µå¼•ç”¨ä¿¡æ¯
			const segmentReferences = segmentFiles.map((f) => ({
				originalPath: f.originalPath,
				segmentId: f.segmentId,
				fileIndex: f.fileIndex,
				originalSize: f.originalSize,
				compressedSize: f.compressedSize,
			}));

			// è¿”å›åˆ†æ®µå­˜å‚¨çš„åŒæ­¥é¡¹
			return {
				...this.convertToSyncItem(item),
				value: JSON.stringify(segmentReferences), // å­˜å‚¨åˆ†æ®µå¼•ç”¨è€Œéç›´æ¥è·¯å¾„
				_syncType: "segmented_files", // æ–°çš„åŒæ­¥ç±»å‹æ ‡è¯†
				_segmentReferences: segmentReferences, // ä¿ç•™å®Œæ•´ä¿¡æ¯ç”¨äºæ¢å¤
				lazyDownload: true,
				fileSize: segmentFiles.reduce((total, f) => total + f.originalSize, 0),
				fileType: "files",
			} as SyncItem;
		} catch (error) {
			this.addLog("error", "æ–‡ä»¶æ•°ç»„åˆ†æ®µå¤„ç†å¤±è´¥ï¼Œå›é€€åˆ°åŸºæœ¬åŒæ­¥", {
				error: error instanceof Error ? error.message : String(error),
				item: { type: item.type, search: item.search?.substring(0, 30) },
			});
			return this.convertToSyncItem(item);
		}
	}

	// åˆ¤æ–­æ–‡ä»¶ç±»å‹
	private getFileType(filePath: string): "images" | "documents" | "text" {
		const ext = filePath.toLowerCase().split(".").pop() || "";

		const imageTypes = [
			"png",
			"jpg",
			"jpeg",
			"gif",
			"bmp",
			"webp",
			"svg",
			"ico",
		];
		const documentTypes = [
			"pdf",
			"doc",
			"docx",
			"xls",
			"xlsx",
			"ppt",
			"pptx",
			"txt",
			"md",
			"rtf",
		];
		const textTypes = [
			"js",
			"ts",
			"css",
			"html",
			"json",
			"xml",
			"yaml",
			"yml",
			"log",
		];

		if (imageTypes.includes(ext)) return "images";
		if (documentTypes.includes(ext)) return "documents";
		if (textTypes.includes(ext)) return "text";
		return "documents"; // é»˜è®¤å½’ç±»ä¸ºæ–‡æ¡£
	}

	// æ£€æŸ¥æ˜¯å¦ä¸ºæ”¯æŒçš„æ–‡ä»¶ç±»å‹
	private isSupportedFileType(filePath: string): boolean {
		const ext = filePath.toLowerCase().split(".").pop() || "";
		const supportedExtensions = [
			// æ–‡æ¡£
			".pdf",
			".doc",
			".docx",
			".xls",
			".xlsx",
			".ppt",
			".pptx",
			".txt",
			".md",
			".rtf",
			// å›¾ç‰‡
			".png",
			".jpg",
			".jpeg",
			".gif",
			".bmp",
			".webp",
			".svg",
			".ico",
			// ä»£ç 
			".js",
			".ts",
			".css",
			".html",
			".json",
			".xml",
			".yaml",
			".yml",
		];

		return supportedExtensions.includes(`.${ext}`);
	}

	// è·å–æ–‡ä»¶å¤§å°
	private async getFileSize(filePath: string): Promise<number> {
		try {
			this.addLog("info", `è·å–æ–‡ä»¶å¤§å°: ${filePath}`);
			const { lstat } = await import("@tauri-apps/plugin-fs");
			const stat = await lstat(filePath);
			const size = stat.size || 0;
			this.addLog(
				"info",
				`æ–‡ä»¶å¤§å°: ${filePath} - ${(size / 1024).toFixed(2)}KB`,
			);
			return size;
		} catch (error) {
			this.addLog("warning", `æ— æ³•è·å–æ–‡ä»¶å¤§å°: ${filePath}`, {
				error: error instanceof Error ? error.message : String(error),
			});
			return 0;
		}
	}

	
	// ä»WebDAVæ¢å¤æ–‡ä»¶
	private async restoreFileFromWebDAV(
		base64Data: string,
		webdavPath: string,
	): Promise<string | null> {
		try {
			this.addLog("info", `ğŸ”„ å¼€å§‹æ¢å¤æ–‡ä»¶: ${webdavPath}`);

			// å°†Base64æ•°æ®è½¬æ¢å›ArrayBuffer
			const compressedData = this.fileProcessor.base64ToArrayBuffer(base64Data);

			// ä»è·¯å¾„ä¸­æå–æ–‡ä»¶å
			const fileName = webdavPath.split("/").pop() || "restored_file";

			// è§£å‹æ–‡ä»¶
			const decompressedData = await this.fileProcessor.decompressFile(
				compressedData,
				fileName,
			);

			// ç”Ÿæˆä¸´æ—¶æ–‡ä»¶è·¯å¾„
			const { appDataDir, join } = await import("@tauri-apps/api/path");
			const tempDir = await join(await appDataDir(), "temp", "sync_files");

			// ç¡®ä¿ç›®å½•å­˜åœ¨
			const { mkdir } = await import("@tauri-apps/plugin-fs");
			try {
				await mkdir(tempDir, { recursive: true });
			} catch {
				// ç›®å½•å¯èƒ½å·²å­˜åœ¨ï¼Œå¿½ç•¥é”™è¯¯
			}

			// åˆ›å»ºå”¯ä¸€æ–‡ä»¶å
			const timestamp = Date.now();
			const randomSuffix = Math.random().toString(36).substring(2, 8);
			const uniqueFileName = `${timestamp}_${randomSuffix}_${fileName}`;
			const tempFilePath = await join(tempDir, uniqueFileName);

			// å†™å…¥æ–‡ä»¶
			const { writeFile } = await import("@tauri-apps/plugin-fs");
			await writeFile(tempFilePath, new Uint8Array(decompressedData));

			this.addLog("success", `âœ… æ–‡ä»¶æ¢å¤æˆåŠŸ: ${tempFilePath}`);
			return tempFilePath;
		} catch (error) {
			this.addLog("error", `âŒ æ–‡ä»¶æ¢å¤å¤±è´¥: ${webdavPath}`, { error });
			return null;
		}
	}

	/**
	 * ç”¨äºåŒæ­¥çš„æ’å…¥æ“ä½œï¼Œé¿å…åˆ é™¤é‡è¦ä¿¡æ¯
	 */
	private async insertForSync(tableName: string, item: any): Promise<void> {
		try {
			this.addLog(
				"info",
				`åŒæ­¥æ’å…¥æ•°æ®: ${item.type} - ${item.search?.substring(0, 30)}... (æ”¶è—: ${item.favorite})`,
			);

			// æ£€æŸ¥æ˜¯å¦å­˜åœ¨ç›¸åŒ type å’Œ value çš„è®°å½•
			const { selectSQL } = await import("@/database");
			const existingRecords = (await selectSQL("history", {
				type: item.type,
				value: item.value,
			})) as any[];

			if (existingRecords && existingRecords.length > 0) {
				// å¦‚æœå­˜åœ¨ï¼Œæ›´æ–°ç°æœ‰è®°å½•ä½†ä¿ç•™é‡è¦å­—æ®µ
				const existing = existingRecords[0];

				// æ™ºèƒ½åˆå¹¶ç­–ç•¥
				const updateItem = {
					...item,
					id: existing.id, // ä¿æŒç°æœ‰ID
					favorite: this.resolveFavoriteStatus(existing, item), // æ™ºèƒ½è§£å†³æ”¶è—çŠ¶æ€å†²çª
					count: Math.max(existing.count || 0, item.count || 0), // å–æ›´å¤§çš„è®¡æ•°å€¼
					createTime: existing.createTime, // ä¿æŒåŸæœ‰åˆ›å»ºæ—¶é—´
				};

				// å¦‚æœæ”¶è—çŠ¶æ€æœ‰å˜åŒ–ï¼Œè®°å½•æ—¥å¿—
				if (existing.favorite !== updateItem.favorite) {
					this.addLog(
						"info",
						`ğŸ”– æ”¶è—çŠ¶æ€æ›´æ–°: ${existing.favorite} â†’ ${updateItem.favorite}`,
						{
							content: item.search?.substring(0, 30),
						},
					);
				}

				const { updateSQL } = await import("@/database");
				await updateSQL("history", updateItem);
				this.addLog("info", `æ›´æ–°ç°æœ‰åŒæ­¥æ•°æ®: ${item.type}`);
			} else {
				// å¦‚æœä¸å­˜åœ¨ï¼Œç›´æ¥æ’å…¥
				const { insertWithDeduplication } = await import("@/database");
				await insertWithDeduplication(tableName as any, item);
				this.addLog(
					"info",
					`æ’å…¥æ–°åŒæ­¥æ•°æ®: ${item.type} (æ”¶è—: ${item.favorite})`,
				);
			}
		} catch (error) {
			this.addLog("error", "åŒæ­¥æ’å…¥å¤±è´¥", { error, item });
			throw error;
		}
	}

	/**
	 * æ™ºèƒ½è§£å†³æ”¶è—çŠ¶æ€å†²çª
	 */
	private resolveFavoriteStatus(existing: any, incoming: any): boolean {
		// å¤„ç†æ•°æ®åº“ä¸­çš„favoriteå­—æ®µï¼Œå¯èƒ½æ˜¯æ•°å­—(0/1)æˆ–å¸ƒå°”å€¼
		const existingIsFavorite =
			existing.favorite === true || existing.favorite === 1;
		const incomingIsFavorite =
			incoming.favorite === true || incoming.favorite === 1;

		// å¦‚æœä»»ä½•ä¸€ä¸ªç‰ˆæœ¬æ˜¯æ”¶è—çš„ï¼Œåˆ™æ ‡è®°ä¸ºæ”¶è—
		if (existingIsFavorite || incomingIsFavorite) {
			return true;
		}

		// å¦‚æœåŒæ­¥æ¨¡å¼æ˜¯æ”¶è—æ¨¡å¼ï¼Œä¸”æ–°æ•°æ®æ˜¯æ”¶è—çš„ï¼Œåˆ™ä»¥æ–°æ•°æ®ä¸ºå‡†
		if (this.syncModeConfig?.settings?.onlyFavorites && incomingIsFavorite) {
			return true;
		}

		// å¦åˆ™ä¿æŒåŸæœ‰çŠ¶æ€
		return existingIsFavorite;
	}

	/**
	 * ç¡®ä¿WebDAVç›®å½•å­˜åœ¨
	 */
	private async ensureWebDAVDirectory(dirPath: string): Promise<void> {
		try {
			this.addLog("info", `æ£€æŸ¥WebDAVç›®å½•: ${dirPath}`);

			const { createDirectory } = await import("@/plugins/webdav");
			const result = await createDirectory(this.config!, dirPath);

			if (result.success) {
				this.addLog("success", `WebDAVç›®å½•åˆ›å»ºæˆåŠŸ: ${dirPath}`);
			} else {
				// ç›®å½•å¯èƒ½å·²å­˜åœ¨ï¼Œè¿™æ˜¯æ­£å¸¸æƒ…å†µ
				this.addLog("info", `WebDAVç›®å½•å·²å­˜åœ¨æˆ–åˆ›å»ºå¤±è´¥: ${dirPath}`, {
					error_message: result.error_message,
				});
			}
		} catch (error) {
			this.addLog("warning", `WebDAVç›®å½•æ£€æŸ¥å¤±è´¥ï¼Œä½†ç»§ç»­å°è¯•ä¸Šä¼ : ${dirPath}`, {
				error: error instanceof Error ? error.message : String(error),
			});
		}
	}

	/**
	 * ä»åˆ†æ®µå­˜å‚¨æ¢å¤æ–‡ä»¶æ•°ç»„
	 */
	private async restoreFilesArrayFromSegments(syncItem: SyncItem): Promise<string | null> {
		try {
			if (syncItem._syncType !== "segmented_files") {
				this.addLog("warning", "éåˆ†æ®µå­˜å‚¨çš„æ–‡ä»¶é¡¹ï¼Œè·³è¿‡æ¢å¤");
				return null;
			}

			const segmentReferences = syncItem._segmentReferences;
			if (!segmentReferences || !Array.isArray(segmentReferences)) {
				this.addLog("error", "åˆ†æ®µå¼•ç”¨ä¿¡æ¯æ— æ•ˆ");
				return null;
			}

			this.addLog("info", `å¼€å§‹ä» ${segmentReferences.length} ä¸ªåˆ†æ®µæ¢å¤æ–‡ä»¶`);

			const restoredFiles: Array<{ name: string; data: string }> = [];

			for (const ref of segmentReferences) {
				this.addLog("info", `æ¢å¤æ–‡ä»¶: ${ref.originalPath} ä»åˆ†æ®µ: ${ref.segmentId}`);

				// ä»åˆ†æ®µè·å–æ–‡ä»¶æ•°æ®
				const fileData = await fileSegmentManager.getFileFromSegment(
					ref.segmentId,
					ref.fileIndex,
					this.config,
				);

				if (!fileData) {
					this.addLog("error", `ä»åˆ†æ®µæ¢å¤æ–‡ä»¶å¤±è´¥: ${ref.originalPath}`);
					continue;
				}

				// è§£å‹æ–‡ä»¶
				const decompressedData = await this.decompressFileData(
					fileData,
					ref.fileIndex.fileName,
				);

				// ä¿å­˜åˆ°æœ¬åœ°
				const localPath = await this.saveFileToLocal(
					decompressedData,
					ref.fileIndex.fileName,
				);

				restoredFiles.push({
					name: ref.fileIndex.fileName,
					data: localPath,
				});

				this.addLog("success", `æ–‡ä»¶æ¢å¤æˆåŠŸ: ${ref.originalPath} -> ${localPath}`);
			}

			if (restoredFiles.length === 0) {
				this.addLog("error", "æ²¡æœ‰æˆåŠŸæ¢å¤çš„æ–‡ä»¶");
				return null;
			}

			this.addLog(
				"success",
				`æ–‡ä»¶æ•°ç»„æ¢å¤å®Œæˆï¼ŒæˆåŠŸæ¢å¤ ${restoredFiles.length} ä¸ªæ–‡ä»¶`,
			);
			return JSON.stringify(restoredFiles);
		} catch (error) {
			this.addLog("error", "æ–‡ä»¶æ•°ç»„æ¢å¤å¤±è´¥", {
				error: error instanceof Error ? error.message : String(error),
			});
			return null;
		}
	}

	/**
	 * è§£å‹æ–‡ä»¶æ•°æ®
	 */
	private async decompressFileData(
		compressedData: ArrayBuffer,
		fileName: string,
	): Promise<ArrayBuffer> {
		try {
			const { default: JSZip } = await import("jszip");
			const zip = new JSZip();
			const zipContent = await zip.loadAsync(compressedData);

			// è·å–æ–‡ä»¶
			const firstFile = Object.values(zipContent.files)[0];
			if (firstFile && !firstFile.dir) {
				return await firstFile.async("arraybuffer");
			}

			throw new Error("ZIPæ–‡ä»¶ä¸­æ²¡æœ‰æ‰¾åˆ°æœ‰æ•ˆå†…å®¹");
		} catch (error) {
			this.addLog("warning", "æ–‡ä»¶è§£å‹å¤±è´¥ï¼Œè¿”å›åŸå§‹æ•°æ®", { error });
			return compressedData;
		}
	}

	/**
	 * ä¿å­˜æ–‡ä»¶åˆ°æœ¬åœ°
	 */
	private async saveFileToLocal(
		fileData: ArrayBuffer,
		fileName: string,
	): Promise<string> {
		try {
			const { downloadDir } = await import("@tauri-apps/api/path");
			const { join } = await import("@tauri-apps/api/path");
			const { writeFile, mkdir } = await import("@tauri-apps/plugin-fs");

			const downloadsPath = await downloadDir();
			const ecoPasteDir = join(downloadsPath, "EcoPaste");
			const filesDir = join(ecoPasteDir, "files");

			// åˆ›å»ºç›®å½•
			try {
				await mkdir(filesDir, { recursive: true });
			} catch {
				// ç›®å½•å¯èƒ½å·²å­˜åœ¨
			}

			// ç”Ÿæˆå”¯ä¸€æ–‡ä»¶å
			const timestamp = Date.now();
			const randomSuffix = Math.random().toString(36).substring(2, 8);
			const uniqueFileName = `${timestamp}_${randomSuffix}_${fileName}`;
			const filePath = join(filesDir, uniqueFileName);

			// ä¿å­˜æ–‡ä»¶
			await writeFile(filePath, new Uint8Array(fileData));

			return filePath;
		} catch (error) {
			this.addLog("error", "ä¿å­˜æ–‡ä»¶å¤±è´¥", { error });
			throw error;
		}
	}

	/**
	 * æ£€æŸ¥æ˜¯å¦å¯ä»¥åŒæ­¥
	 */
	canSync(): boolean {
		return this.isOnline && !!this.config;
	}

	/**
	 * ä¸‹è½½è¿œç¨‹åŒæ­¥æ•°æ®
	 */
	private async downloadRemoteData(): Promise<SyncData | null> {
		try {
			const filePath = this.getFullSyncFilePath();
			const result = await downloadSyncData(this.config!, filePath);

			if (result.success && result.data) {
				const remoteData = JSON.parse(result.data);
				this.addLog("info", "âœ… è¿œç¨‹æ•°æ®ä¸‹è½½æˆåŠŸ", {
					è¿œç¨‹é¡¹ç›®æ•°é‡: remoteData.items?.length || 0,
					åˆ é™¤è®°å½•æ•°é‡: remoteData.deleted?.length || 0,
				});
				return remoteData;
			} else {
				this.addLog("warning", "âš ï¸ è¿œç¨‹æ•°æ®ä¸‹è½½å¤±è´¥", {
					error: result.error_message,
				});
				return null;
			}
		} catch (error) {
			this.addLog("error", "âŒ ä¸‹è½½è¿œç¨‹æ•°æ®å¼‚å¸¸", {
				error: error instanceof Error ? error.message : String(error),
			});
			return null;
		}
	}

	/**
	 * å¤„ç†ZIPå›¾ç‰‡æ–‡ä»¶åŒæ­¥
	 */
	private async processZipImageFilesSync(
		remoteItems: SyncItem[],
		localItems: SyncItem[],
	): Promise<void> {
		try {
			// æ‰¾å‡ºæ‰€æœ‰éœ€è¦åŒæ­¥çš„ZIPå›¾ç‰‡é¡¹ç›®
			const remoteImageItems = remoteItems.filter(
				(item) => item.type === "image" && item._syncType === "zip_files"
			);

			if (remoteImageItems.length === 0) {
				this.addLog("info", "ğŸ“· æ²¡æœ‰éœ€è¦åŒæ­¥çš„ZIPå›¾ç‰‡æ–‡ä»¶");
				return;
			}

			this.addLog("info", `ğŸ–¼ï¸ å‘ç° ${remoteImageItems.length} ä¸ªZIPå›¾ç‰‡æ–‡ä»¶éœ€è¦åŒæ­¥`);

			// æå–å›¾ç‰‡æ•°æ®ä¿¡æ¯
			const imageDataList: any[] = [];
			for (const item of remoteImageItems) {
				try {
					const imageData = JSON.parse(item.value);
					this.addLog("info", "ğŸ” è§£æZIPå›¾ç‰‡æ•°æ®ç»“æ„", {
						itemId: item.id,
						imageDataType: Array.isArray(imageData) ? "array" : typeof imageData,
						imageDataLength: Array.isArray(imageData) ? imageData.length : undefined,
						firstImageData: Array.isArray(imageData) && imageData.length > 0 ? {
							hasOriginalPath: !!imageData[0].originalPath,
							hasZipName: !!imageData[0].zipName,
							originalPath: imageData[0].originalPath?.substring(0, 50) + "...",
							zipName: imageData[0].zipName
						} : undefined
					});

					// imageData æ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œæ¯ä¸ªå…ƒç´ éƒ½åŒ…å« zipName
					if (Array.isArray(imageData)) {
						for (const imageInfo of imageData) {
							if (imageInfo.zipName && imageInfo.originalPath) {
								imageDataList.push(imageInfo);
							} else {
								this.addLog("error", "âŒ ZIPå›¾ç‰‡æ•°æ®ç¼ºå°‘å¿…è¦å­—æ®µ", {
									itemId: item.id,
									hasZipName: !!imageInfo.zipName,
									hasOriginalPath: !!imageInfo.originalPath,
									imageInfo
								});
							}
						}
					}
				} catch (error) {
					this.addLog("error", "âŒ è§£æZIPå›¾ç‰‡æ•°æ®å¤±è´¥", {
						itemId: item.id,
						error: error instanceof Error ? error.message : String(error),
						rawValue: item.value?.substring(0, 100) + "..."
					});
				}
			}

			// æ‰¹é‡ä¸‹è½½å’Œä¿å­˜å›¾ç‰‡
			const pathMappings = await zipImageSyncService.batchSyncImages(
				imageDataList,
				this.config!,
			);

			// æ›´æ–°æ•°æ®åº“ä¸­çš„è·¯å¾„å¼•ç”¨
			for (const imageData of imageDataList) {
				const newPath = pathMappings.get(imageData.originalPath);
				if (newPath) {
					// æ›´æ–°æ•°æ®åº“ä¸­çš„è·¯å¾„
					await updateSQL("history", {
						id: remoteImageItems.find((item) =>
							item.value.includes(imageData.originalPath)
						)?.id,
						value: newPath,
					});
					this.addLog("info", "ğŸ“ ZIPå›¾ç‰‡è·¯å¾„å·²æ›´æ–°", {
						originalPath: imageData.originalPath,
						newPath: newPath,
					});
				}
			}

			this.addLog("success", "âœ… ZIPå›¾ç‰‡æ–‡ä»¶åŒæ­¥å®Œæˆ", {
				å¤„ç†å›¾ç‰‡æ•°é‡: imageDataList.length,
				æˆåŠŸæ•°é‡: pathMappings.size,
			});
		} catch (error) {
			this.addLog("error", "âŒ ZIPå›¾ç‰‡æ–‡ä»¶åŒæ­¥å¤±è´¥", {
				error: error instanceof Error ? error.message : String(error),
			});
		}
	}

	/**
	 * å¤„ç†å›¾ç‰‡æ–‡ä»¶åŒæ­¥
	 */
	private async processImageFilesSync(
		remoteItems: SyncItem[],
		localItems: SyncItem[],
	): Promise<void> {
		try {
			// æ‰¾å‡ºæ‰€æœ‰éœ€è¦åŒæ­¥çš„å›¾ç‰‡é¡¹ç›®
			const remoteImageItems = remoteItems.filter(
				(item) => item.type === "image" && item._syncType === "segmented_files"
			);

			if (remoteImageItems.length === 0) {
				this.addLog("info", "ğŸ“· æ²¡æœ‰éœ€è¦åŒæ­¥çš„å›¾ç‰‡æ–‡ä»¶");
				return;
			}

			this.addLog("info", `ğŸ–¼ï¸ å‘ç° ${remoteImageItems.length} ä¸ªå›¾ç‰‡æ–‡ä»¶éœ€è¦åŒæ­¥`);

			// æå–å›¾ç‰‡æ•°æ®ä¿¡æ¯
			const imageDataList: any[] = [];
			for (const item of remoteImageItems) {
				try {
					const imageData = JSON.parse(item.value);
					this.addLog("info", "ğŸ” è§£æå›¾ç‰‡æ•°æ®ç»“æ„", {
						itemId: item.id,
						imageDataType: Array.isArray(imageData) ? "array" : typeof imageData,
						imageDataLength: Array.isArray(imageData) ? imageData.length : undefined,
						firstImageData: Array.isArray(imageData) && imageData.length > 0 ? {
							hasOriginalPath: !!imageData[0].originalPath,
							hasSegmentId: !!imageData[0].segmentId,
							originalPath: imageData[0].originalPath?.substring(0, 50) + "...",
							segmentId: imageData[0].segmentId
						} : undefined
					});

					// imageData æ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œæ¯ä¸ªå…ƒç´ éƒ½åŒ…å« segmentId
					if (Array.isArray(imageData)) {
						for (const imageInfo of imageData) {
							if (imageInfo.segmentId && imageInfo.originalPath) {
								imageDataList.push(imageInfo);
							} else {
								this.addLog("error", "âŒ å›¾ç‰‡æ•°æ®ç¼ºå°‘å¿…è¦å­—æ®µ", {
									itemId: item.id,
									hasSegmentId: !!imageInfo.segmentId,
									hasOriginalPath: !!imageInfo.originalPath,
									imageInfo
								});
							}
						}
					}
				} catch (error) {
					this.addLog("error", "âŒ è§£æå›¾ç‰‡æ•°æ®å¤±è´¥", {
						itemId: item.id,
						error: error instanceof Error ? error.message : String(error),
						rawValue: item.value?.substring(0, 100) + "..."
					});
				}
			}

			// æ‰¹é‡ä¸‹è½½å’Œä¿å­˜å›¾ç‰‡
			const pathMappings = await imageSyncService.batchSyncImages(
				imageDataList,
				this.config!,
			);

			// æ›´æ–°æ•°æ®åº“ä¸­çš„è·¯å¾„å¼•ç”¨
			for (const imageData of imageDataList) {
				const newPath = pathMappings.get(imageData.originalPath);
				if (newPath) {
					// æ›´æ–°æ•°æ®åº“ä¸­çš„è·¯å¾„
					await updateSQL("history", {
						id: remoteImageItems.find((item) =>
							item.value.includes(imageData.originalPath)
						)?.id,
						value: newPath,
					});
					this.addLog("info", "ğŸ“ å›¾ç‰‡è·¯å¾„å·²æ›´æ–°", {
						originalPath: imageData.originalPath,
						newPath: newPath,
					});
				}
			}

			this.addLog("success", "âœ… å›¾ç‰‡æ–‡ä»¶åŒæ­¥å®Œæˆ", {
				å¤„ç†å›¾ç‰‡æ•°é‡: imageDataList.length,
				æˆåŠŸæ•°é‡: pathMappings.size,
			});
		} catch (error) {
			this.addLog("error", "âŒ å›¾ç‰‡æ–‡ä»¶åŒæ­¥å¤±è´¥", {
				error: error instanceof Error ? error.message : String(error),
			});
		}
	}

	/**
	 * ä¸‹è½½è¿œç¨‹æ•°æ®å¹¶å¤„ç†å›¾ç‰‡æ–‡ä»¶åŒæ­¥
	 */
	private async downloadRemoteDataAndProcessImages(): Promise<void> {
		try {
			// 1. ä¸‹è½½è¿œç¨‹æ•°æ®
			const remoteData = await this.downloadRemoteData();
			if (!remoteData) {
				this.addLog("info", "ğŸ“­ æ²¡æœ‰è¿œç¨‹æ•°æ®ï¼Œè·³è¿‡å›¾ç‰‡åŒæ­¥");
				return;
			}

			// 2. è·å–æœ¬åœ°æ•°æ®
			const localData = await getHistoryData();
			const localItems: SyncItem[] = (localData as any[]).map((item: any) => ({
				id: item.id,
				type: item.type,
				group: item.group,
				value: item.value,
				search: item.search,
				count: item.count,
				width: item.width,
				height: item.height,
				favorite: item.favorite,
				createTime: item.createTime,
				note: item.note,
				subtype: item.subtype,
			}));

			// 3. å¤„ç†å›¾ç‰‡æ–‡ä»¶åŒæ­¥ï¼ˆZIPæ¨¡å¼ä¼˜å…ˆï¼‰
			await this.processZipImageFilesSync(remoteData.items, localItems);
			// 4. å¤„ç†æ—§çš„åˆ†æ®µæ–‡ä»¶åŒæ­¥ï¼ˆå…¼å®¹æ€§ï¼‰
			await this.processImageFilesSync(remoteData.items, localItems);

		} catch (error) {
			this.addLog("error", "âŒ ä¸‹è½½è¿œç¨‹æ•°æ®å¹¶å¤„ç†å›¾ç‰‡åŒæ­¥å¤±è´¥", {
				error: error instanceof Error ? error.message : String(error),
			});
		}
	}

	/**
	 * è·å–å®Œæ•´åŒæ­¥æ–‡ä»¶è·¯å¾„
	 */
	private getFullSyncFilePath(): string {
		const basePath = this.config?.path || "/EcoPaste";
		return `${basePath}/sync-data.json`;
	}
}

// åˆ›å»ºå…¨å±€åŒæ­¥å¼•æ“å®ä¾‹
export const syncEngine = new SyncEngine();
